---
layout: post
title: 'ODE講座14: 七転び八起き'
date: 2006-06-04 12:31:13.000000000 +09:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- ode
tags: []
meta:
  _edit_last: '2'
  views: '1245'
author:
  login: demu
  email: info@demura.net
  display_name: demu
  first_name: ''
  last_name: ''
permalink: "/robot/9ode/286.html"
---
<p> <img src="{{ site.baseurl }}/assets/images/2006/06/koboshi.gif" border="0" alt="" /></p>
<p>ODE(Open Dynamics Engine)講座の１４回目です。今回は重心の位置を移動する方法について説明します。</p>
<p>AKさんから重心の移動についてご質問があったので回答がてら起き上がり小法師（こぼし）のプログラムを作りました．民主党の前原前代表に配られた起き上がり小法師が倒れたままだった事件はまだ記憶に新しいですね．</p>
<p> さて，ODEにはdMassTranslateというAPIがありますが，これを使うだけでは重心を移動できません．ODE User Guideの10.7.7 Geometry Transform Classに" for example, you can offset the center of a sphere, or rotate a cylinder so that its axis is something other than the default."という記述があるようにGeometry Transformオブジェクトと一緒に使わなければいけません．<br />
 </p>
<p><!--more--></p>
<p>具体的にはGeometry Transformオブジェクト（例では小法師の胴体）にカプセル化(encapsulate)される球オブジェクト（例では頭）の重心をGeometry Transformオブジェクトの重心からずらして設定し，Geometry Transformの位置もそのオフセットを打ち消すように設定しなければなりません．この辺の詳しい説明はODEのメーリングリスト（英語）で5月末から議論されています．</p>
<p>この例では， 小法師の胴体に相当する球の質量を10kg，半径を0.4m，重心を球の中心より0.4m下に設定しています．小法師の頭に相当する球の質量は1gに設定しています．j, f キーを押すと小法師を左右に転倒させるモーメントが働きますが，この小法師なら必ず起き上がってくれます．重心のオフセットをいろいろ変えて動作を確認してみてください．</p>
<p>なお，メーリングリストを読むとODEの次期バージョン0.06のRC2ではdGeomSetOffsetPositionが使え，もっと簡単に重心のオフセットを設定できるようなことが書かれていました．それについてはまだ試していません．</p>
<p>// koboshi.c by Kosei Demura 2006-6-4<br />
// My web site is http://demura.net<br />
// This program uses the Open Dynamics Engine (ODE) by Russell Smith.<br />
// The ODE web site is http://ode.org/<br />
#include &lt;ode/ode.h&gt;<br />
#include &lt;drawstuff/drawstuff.h&gt;<br />
#ifdef dDOUBLE<br />
#define dsDrawSphere dsDrawSphereD<br />
#endif<br />
#define MAX_CONTACTS 4</p>
<p>static dWorldID world;<br />
static dSpaceID space;<br />
static dGeomID  ground;<br />
static dJointGroupID contactgroup;<br />
dsFunctions fn;</p>
<p>typedef struct {    <br />
  dBodyID body;     <br />
  dGeomID geom;     <br />
  dReal   radius;<br />
  dReal   length;<br />
  dReal   mass;<br />
} MyLink;</p>
<p>MyLink trans_ball;  　　　　　　 // Geometry Transformオブジェクト<br />
MyLink ball;  <br />
dGeomID  encap_ball_geom;   // Geometry Transformオブジェクトに格納されるオブジェクト<br />
dJointID joint;</p>
<p>static void nearCallback (void *data, dGeomID o1, dGeomID o2)<br />
{<br />
  int i;</p>
<p>  // exit without doing anything if the two bodies are connected by a joint             <br />
  dBodyID b1 = dGeomGetBody(o1);<br />
  dBodyID b2 = dGeomGetBody(o2);<br />
  if (b1 &amp;&amp; b2 &amp;&amp; dAreConnectedExcluding (b1,b2,dJointTypeContact)) return;</p>
<p>  dContact contact[MAX_CONTACTS];   // up to MAX_CONTACTS contacts per box-box          <br />
  for (i=0; i&lt;MAX_CONTACTS; i++) {<br />
    contact[i].surface.mode = dContactBounce | dContactSoftCFM;<br />
    contact[i].surface.mu = 5;<br />
    contact[i].surface.bounce = 0.01;<br />
    contact[i].surface.bounce_vel = 0.01;<br />
    contact[i].surface.soft_cfm = 0.00001;<br />
  }<br />
  if (int numc = dCollide (o1,o2,MAX_CONTACTS,&amp;contact[0].geom,<br />
                           sizeof(dContact))) {<br />
    for (i=0; i&lt;numc; i++) {<br />
      dJointID c = dJointCreateContact (world,contactgroup,contact+i);<br />
      dJointAttach (c,b1,b2);<br />
    }<br />
  }<br />
}</p>
<p>static void drawGeom(dGeomID g, const dReal *pos, const dReal *R)<br />
{<br />
  if (!g) return;<br />
  if (!pos) pos = dGeomGetPosition(g);<br />
  if (!R) R = dGeomGetRotation(g);</p>
<p>  int type = dGeomGetClass(g);</p>
<p>  if (type == dCCylinderClass) {<br />
    dReal radius,length;<br />
    dGeomCCylinderGetParams(g,&amp;radius,&amp;length);<br />
    dsDrawCappedCylinderD(pos,R,length,radius);<br />
  }<br />
  else if (type == dSphereClass) {<br />
    dsDrawSphereD(pos,R,dGeomSphereGetRadius (g));<br />
  }<br />
  else if (type == dGeomTransformClass) {<br />
    dGeomID g2 = dGeomTransformGetGeom(g);<br />
    const dReal *pos2 = dGeomGetPosition(g2);<br />
    const dReal *R2   = dGeomGetRotation(g2);<br />
    dVector3 actual_pos;<br />
    dMatrix3 actual_R;<br />
    dMULTIPLY0_331(actual_pos,R,pos2);<br />
    actual_pos[0] += pos[0];<br />
    actual_pos[1] += pos[1];<br />
    actual_pos[2] += pos[2];<br />
    dMULTIPLY0_333 (actual_R,R,R2);<br />
    drawGeom(g2,actual_pos,actual_R);<br />
  }<br />
}</p>
<p>static void simLoop (int pause)<br />
{<br />
  dSpaceCollide(space,0,&amp;nearCallback);<br />
  dWorldStep(world,0.01);<br />
  dJointGroupEmpty(contactgroup);<br />
  dsSetColor(1.0,0.0,0.0);<br />
  drawGeom(trans_ball.geom, 0, 0);<br />
  drawGeom(ball.geom, 0, 0);<br />
}</p>
<p>void start()<br />
{<br />
  static float xyz[3] = {   3.5,0.0,1.0};<br />
  static float hpr[3] = {-180.0,0.0,0.0};<br />
  dsSetSphereQuality(3);<br />
  dsSetViewpoint (xyz,hpr);<br />
}</p>
<p>// Create an object<br />
void createKoboshi() {<br />
  dMass m,m1;<br />
  dReal x0 = 0.0, y0 = 0.0, z0 = 1.0;  // 胴体重心の初期位置[m]<br />
  dReal dx = 0.0, dy = 0.0, dz = 0.4;  // 重心のオフセット [m]</p>
<p>  trans_ball.geom = dCreateGeomTransform(space); 　// Geometry Transformオブジェクトのジオメトリを作成<br />
  trans_ball.body = dBodyCreate(world);　　　　　　　　// Geometry Transformオブジェクトのボディを作成<br />
  dGeomTransformSetCleanup(trans_ball.geom,1); 　　// Geomery Transformのお掃除モード設定</p>
<p>  // 胴体: 重心を移動したボール　<br />
  trans_ball.radius = 0.4;    // 球の半径0.4m<br />
  trans_ball.mass   = 10.0; // 球の質量　10kg<br />
  dMassSetZero(&amp;m);　　　// 質量パラメータの初期化<br />
  dMassSetSphereTotal(&amp;m,trans_ball.mass,trans_ball.radius); 　// 球の質量パラメータの計算</p>
<p>  encap_ball_geom = dCreateSphere(0,trans_ball.radius);  //　カプセル化されるオブジェクトのスペースには0を入れ，ボディを作ってはいけない<br />
  // カプセル化される球のジオメトリencap_ball_geomをGeometry Transformオブジェクトであるtrans_ball.geomジオメトリに設定する（これによりカプセル化される）<br />
  dGeomTransformSetGeom(trans_ball.geom,encap_ball_geom);</p>
<p>  dGeomSetPosition(encap_ball_geom, dx, dy, dz);　// ジオメトリをオフセット分移動　<br />
　dMassTranslate(&amp;m, dx, dy, dz);　// 重心をオフセット分移動</p>
<p>  dGeomSetBody(trans_ball.geom,trans_ball.body);  // ボディとジオメトリの対応づけ     <br />
  dBodySetMass(trans_ball.body,&amp;m);     　　　　　　// ボディに質量パラメータを設定       <br />
  dGeomSetPosition(trans_ball.geom, x0 -dx, y0 -dy, z0 - dz);　// オフセットの分を考慮してGeometry Tranformオブジェクトの位置を設定</p>
<p>  // 頭<br />
  ball.radius = 0.3;       // 球の半径　0.3m<br />
  ball.mass   = 0.001;  //  質量　0.001kg<br />
  ball.body   = dBodyCreate(world);   <br />
  dMassSetZero(&amp;m1);<br />
  dMassSetSphereTotal(&amp;m1,ball.mass, ball.radius);<br />
  dBodySetMass(ball.body,&amp;m1);            <br />
  dBodySetPosition(ball.body, x0, y0, z0 + trans_ball.radius + ball.radius);<br />
  ball.geom = dCreateSphere(space,ball.radius);<br />
  dGeomSetBody(ball.geom,ball.body);      </p>
<p>  // fixed joint<br />
  joint = dJointCreateFixed(world, 0);<br />
  dJointAttach(joint, trans_ball.body,ball.body);<br />
  dJointSetFixed(joint);<br />
}</p>
<p>void command(int cmd)<br />
{<br />
  switch(cmd) {<br />
  case 'f':<br />
    dBodyAddTorque(ball.body,  100, 0, 0); break;<br />
  case 'j':<br />
    dBodyAddTorque(ball.body, -100, 0, 0); break;<br />
  }<br />
}</p>
<p>void  setDrawStuff() {<br />
  fn.version = DS_VERSION;<br />
  fn.start   = &amp;start;<br />
  fn.step    = &amp;simLoop;<br />
  fn.command = &amp;command;<br />
  fn.stop    = NULL;<br />
  fn.path_to_textures = "../../drawstuff/textures";<br />
}</p>
<p>int main (int argc, char **argv)<br />
{<br />
  setDrawStuff();<br />
  world = dWorldCreate();<br />
  space = dHashSpaceCreate(0);<br />
  contactgroup = dJointGroupCreate(0);<br />
  dWorldSetGravity(world,0,0,-9.8);<br />
  ground = dCreatePlane(space,0,0,1,0);<br />
  createKoboshi();<br />
  dsSimulationLoop (argc,argv,640,480,&amp;fn);<br />
  dWorldDestroy (world);<br />
  return 0;<br />
}</p>
<p><a href="http://demura.net/archives/images/ode/koboshi.tar" target="_self">ここからソースコードをダウンロードできます． </a></p>
<p>おしまい！</p>
