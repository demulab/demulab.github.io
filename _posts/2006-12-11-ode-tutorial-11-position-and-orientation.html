---
layout: post
title: 'ODE Tutorial 11: Position and Orientation'
date: 2006-12-11 23:14:40.000000000 +09:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- english
tags: []
meta:
  _edit_last: '2'
  views: '666'
author:
  login: demu
  email: info@demura.net
  display_name: demu
  first_name: ''
  last_name: ''
permalink: "/english/356.html"
---
<p>This page was translated from http://demura.net/archives/9ode by <a href="http://babelfish.altavista.com/">Babel Fish Translation</a>.</p>
<p><img src="{{ site.baseurl }}/assets/images/2006/12/rightHands.jpg" alt="" width="240" height="214" /></p>
<p>The coordinates system of ODE (right hand system)</p>
<p>ODE (Open Dynamcs Engine) lecture time it is 11th. This time the method where the system of coordinates of ODE and  position attitude of rigid body it sets and acquires and is explained.</p>
<p><strong>System of coordinates</strong></p>
<p>The system of coordinates of ODE as shown in the  upper figure, is orthogonal coordinate of the right hand type which is used generally in physics and mathematics. In the center of the  small pyramid where 9 there is a starting point, red pyramid direction x axis, blue pyramid direction the Y-axis and sky direction has become the z axis from the center. Furthermore, being to be good with  anything, it does, system of units, but because with this lecture SI  system of units is adopted, each pyramid has lined up at the interval  at a time of 1m.</p>
<p><strong>Setting of position and orientation</strong></p>
<p>In order to set rigid body with respect to 3  dimensional spaces, it is necessary to appoint position and attitude.  As for attitude it is possible to decide with rotational  transform queue, by API below it is setting possible even with ODE.</p>
<p><strong style="color: #000066">void dBodySetPosition (dBodyID, dReal x, dReal y,  dReal z);</strong><br />
<span style="font-weight: normal; color: #000000;">Center of gravity of rigid body dBodyID is set position  of world coordinate system (x, y, z).</span></p>
<p><strong style="color: #000066">void dRFromAxisAndAngle (dMatrix3 R, dReal ax, dReal ay, dReal az, dReal angle);</strong><span style="color: #000066;"><br />
</span> When axis of rotation vector (ax, ay, az) the around  angle [ rad ] turning in anticlockwise, rotation matrix R  is acquired.</p>
<p><strong style="color: #000066">void dBodySetRotation (dBodyID, const dMatrix3 R); </strong><br />
Attitude of rigid body dBodyID is set to revolution queue  R.</p>
<p>In addition, with ODE API and void dBodySetQuaternion in  addition regarding quaternion (dBodyID and const  dQuaternion q) it is.</p>
<p><!--more--></p>
<p><strong>Acquisition of Position and Orientation</strong></p>
<p><strong style="color: #000066">Const dReal * dBodyGetPosition (dBodyID);</strong><br />
<span style="font-weight: normal; color: #000000;">Position of rigid body dBodyID is acquired. As  for return value the pointer to the arrangement to which position with world coordinate system is housed.</span></p>
<p><strong style="color: #000066">Const dReal * dBodyGetRotation (dBodyID);</strong><br />
<span style="font-weight: normal; color: #000000;">Revolution it forms a line acquires of rigid body  dBodyID. As for return value the pointer to the arrangement to  which revolution queue is housed.</span></p>
<p><!-- ▼追記▼ --></p>
<hr /><strong>A Sample Code<br />
</strong>The next sample cord/code position (0.0, 0.0,  1.0), 45 degrees (M_PI/4.0) has set the cylinder to the attitude which turned around x axis. Furthermore, the function printPos which  indicates the balance station of the object () it added.  Furthermore, the cylinder unless attitude is set, has become  attitude of standing upright where the extended shaft matches z axial  direction.</p>
<p>[code]<br />
typedef struct {<br />
dBodyID body;<br />
dGeomID geom;<br />
} MyObject;<br />
MyObject pillar;</p>
<p>void createPillar()<br />
{<br />
dMass m1;<br />
dReal radius = 0.1, length = 0.5, mass = 1.0;</p>
<p>pillar.body = dBodyCreate(world);<br />
dMassSetZero(&amp;m1);<br />
dMassSetCylinderTotal(&amp;m1,mass,3,radius,length);<br />
dBodySetMass(pillar.body,&amp;m1);<br />
dBodySetPosition(pillar.body,　0.0, 0.0,  1.0);   // Set a center of gravity to (0.0, 0.0, 1.0)<br />
dMatrix3 R;<br />
dRFromAxisAndAngle(R, 1.0, 0.0, 0.0,  M_PI/ 4.0);　// rotatio π/4[rad] around the x axis<br />
dBodySetRotation(pillar.body,R);<br />
pillar.geom = dCreateCylinder(space,radius,length);<br />
dGeomSetBody(pillar.geom,pillar.body);<br />
}</p>
<p>void printPos(dBodyID obj_body)  // print a position of COG<br />
{<br />
const dReal *pos;<br />
dReal x, y, z;<br />
pos  = dBodyGetPosition(obj_body);<br />
x = pos[0];<br />
y = pos[1];<br />
z = pos[2];<br />
printf("x=%f y=%f z=%f \n", x, y, z);<br />
}</p>
<p>[/code]</p>
<p>To be continue.</p>
