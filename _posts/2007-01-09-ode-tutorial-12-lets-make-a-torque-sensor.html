---
layout: post
title: 'ODE Tutorial 12: Let''s make a torque sensor !'
date: 2007-01-09 14:28:57.000000000 +09:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- english
tags: []
meta:
  _edit_last: '2'
  views: '821'
author:
  login: demu
  email: info@demura.net
  display_name: demu
  first_name: ''
  last_name: ''
permalink: "/english/363.html"
---
<p>This page was maily translated from http://demura.net/archives/9ode by <a href="http://babelfish.altavista.com/">Babel Fish Translation</a>.</p>
<p>As been in the question from Jimmy, as for the command which  inspects torque and the power which depend on the joint it  is  net easy to find on the ODE user manual.</p>
<p>With ODE the torque and the like which falls on the joint  cannot be acquired immediately. In order to acquire, after  appointing the joint with dJointSetFeedback, you acquire information  with dJointGetFeedback. As for this is in order to improve  performance. It is not the case that power and the torque which  fall on all joints always are necessary don't you think?.</p>
<ul>
<li><span style="color: #000066;"><strong>Void dJointSetFeedback (dJointID and dJointFeedback *);</strong></span><br />
The joint which acquires the information of power and  torque is appointed with dJointID. The dJointFeedback structure  is as follows.</p>
<p>typedef struct dJointFeedback {<br />
dVector3 f1;  // The power which the joint has  caused to body 1<br />
dVector3 t1;  // The torque which the joint has  caused to body 1<br />
dVector3 f2;  // The power which the joint has  caused to body 2<br />
dVector3 t2; / / The torque which the joint has  caused to body 2<br />
} dJointFeedback;</li>
<li><span style="color: #000066;"><strong>dJointFeedback *dJointGetFeedback (dJointID);</strong></span><br />
Information of power and torque of the joint which it is  designated with dJointID is acquired.</li>
</ul>
<p><!-- ▼追記▼ -->Next, the sample program which used this API is  introduced. The box is raised the fixed joint (Fixed Joint) with the land (static object), the stick and the box where the weight has  been attached with the fixed joint which becomes the sensor there are  connected. It is the program which indicates the power which  depends on the sensor. You can ignore the weight of the stick  almost with 0.0001kg. It meaning that mass of the weight is 1kg, torque of the around x axis if it is 9.8Nm, is good reason. With my environment according to theory it had started hitting the value of 9.8.<br />
<!--more--></p>
<p>[code]<br />
// torque.cpp  by Kosei Demura  2006-12-05<br />
#include<br />
#include</p>
<p>#ifdef dDOUBLE<br />
#define dsDrawCylinder dsDrawCylinderD<br />
#define dsDrawSphere   dsDrawSphereD<br />
#endif</p>
<p>static dWorldID world;<br />
static dSpaceID space;<br />
static dGeomID  ground;<br />
static dJointID sensor,fixed[2];<br />
static dJointGroupID contactgroup;<br />
dJointFeedback *feedback = new dJointFeedback;<br />
dsFunctions fn;</p>
<p>typedef struct {<br />
dBodyID body;<br />
dGeomID geom;<br />
dReal   radius,length,width,height,mass;<br />
} myLink;<br />
myLink stick, ball, box;</p>
<p>static void nearCallback (void *data, dGeomID o1, dGeomID o2)<br />
{<br />
static int MAX_CONTACTS = 10;<br />
int i;</p>
<p>// exit without doing anything if the two bodies are connected by a joint<br />
dBodyID b1 = dGeomGetBody(o1);<br />
dBodyID b2 = dGeomGetBody(o2);<br />
if (b1 &amp;&amp; b2 &amp;&amp; dAreConnected(b1,b2)) return;</p>
<p>dContact contact[MAX_CONTACTS];   // up to MAX_CONTACTS contacts per box-box<br />
int numc = dCollide(o1,o2,MAX_CONTACTS,&amp;contact[0].geom,<br />
sizeof(dContact));<br />
if (numc &gt; 0) {<br />
for (i=0; i<br />
contact[i].surface.mode  =  dContactSoftCFM | dContactSoftERP;<br />
contact[i].surface.mu       = dInfinity;<br />
contact[i].surface.soft_cfm = 1e-8;<br />
contact[i].surface.soft_erp = 1.0;<br />
dJointID c = dJointCreateContact(world,contactgroup,&amp;contact[i]);</p>
<p>dJointAttach (c,dGeomGetBody(contact[i].geom.g1),<br />
dGeomGetBody(contact[i].geom.g2));<br />
}<br />
}<br />
}</p>
<p>static void simLoop (int pause)<br />
{<br />
static int steps = 0;</p>
<p>dSpaceCollide(space,0,&amp;nearCallback);<br />
dWorldStep(world,0.01);<br />
dJointGroupEmpty(contactgroup);</p>
<p>feedback = dJointGetFeedback(sensor);<br />
printf("%5d Torque Tx=%6.2f ",steps++,feedback-&gt;t1[0]);<br />
printf("Ty=%6.2f ",feedback-&gt;t1[1]);<br />
printf("Tz=%6.2f \n",feedback-&gt;t1[2]);</p>
<p>// draw a box<br />
dsSetColor(1.3,1.3,0.0);<br />
dReal sides1[] = {box.length,box.width,box.height};<br />
dsDrawBoxD(dBodyGetPosition(box.body),<br />
dBodyGetRotation(box.body),sides1);</p>
<p>// draw a ball<br />
dsSetColor(1.3,0.0,0.0);<br />
dsDrawSphere(dBodyGetPosition(ball.body),<br />
dBodyGetRotation(ball.body),ball.radius);</p>
<p>// draw a stick<br />
dsSetColor(0.0,0.0,1.3);<br />
dsDrawCylinder(dBodyGetPosition(stick.body),<br />
dBodyGetRotation(stick.body),stick.length, stick.radius);<br />
}</p>
<p>void start()<br />
{<br />
static float xyz[3] = {3.0,0.0,1.0};<br />
static float hpr[3] = {180.0,0.0,0.0};<br />
dsSetViewpoint (xyz,hpr);<br />
dsSetSphereQuality(3);<br />
}</p>
<p>void  setDrawStuff() {<br />
fn.version = DS_VERSION;<br />
fn.start   = &amp;start;<br />
fn.step    = &amp;simLoop;<br />
fn.command = NULL;<br />
fn.stop    = NULL;<br />
fn.path_to_textures = "../../drawstuff/textures";<br />
}</p>
<p>int main(int argc, char **argv)<br />
{<br />
setDrawStuff();</p>
<p>world = dWorldCreate();<br />
space = dHashSpaceCreate(0);<br />
contactgroup = dJointGroupCreate(0);<br />
dWorldSetGravity(world,0,0,-9.8);<br />
dWorldSetERP(world,1.0);</p>
<p>// Create a ground<br />
ground = dCreatePlane(space,0,0,1,0);</p>
<p>dMass m1;<br />
dReal x0 = 0.0, y0 = 0.0, z0 = 0.5;<br />
dReal x1 = 0.0, y1 = 0.5, z1 = 1.0;<br />
dReal x2 = 0.0, y2 = 1.0, z2 = 1.0;<br />
dMatrix3 R;</p>
<p>// box<br />
box.length = 0.1;  box.width  = 0.1;<br />
box.height = 1.0;  box.mass   = 1.0;<br />
box.body   = dBodyCreate(world);<br />
dMassSetZero(&amp;m1);<br />
dMassSetBoxTotal(&amp;m1,box.mass,box.length,box.width,box.height);<br />
dBodySetMass(box.body,&amp;m1);<br />
dBodySetPosition(box.body, x0, y0, z0);<br />
box.geom = dCreateBox(space,box.length,box.width,box.height);<br />
dGeomSetBody(box.geom,box.body);</p>
<p>// stick<br />
stick.length = 1.0;  stick.radius = 0.01;<br />
stick.mass   = 0.0001;<br />
stick.body   = dBodyCreate(world);<br />
dMassSetZero(&amp;m1);<br />
dMassSetCylinderTotal(&amp;m1,stick.mass,3, stick.radius, stick.length);<br />
dBodySetMass(stick.body,&amp;m1);<br />
dBodySetPosition(stick.body, x1, y1, z1);<br />
dRFromAxisAndAngle(R, 1, 0, 0, M_PI/2);<br />
dBodySetRotation(stick.body, R);<br />
stick.geom = dCreateCylinder(space,stick.radius,stick.length);<br />
dGeomSetBody(stick.geom,stick.body);</p>
<p>// ball<br />
ball.radius = 0.1;<br />
ball.mass   = 1.0;<br />
ball.body   = dBodyCreate(world);<br />
dMassSetZero(&amp;m1);<br />
dMassSetSphereTotal(&amp;m1,ball.mass,ball.radius);<br />
dBodySetMass(ball.body,&amp;m1);<br />
dBodySetPosition(ball.body, x2, y2, z2);<br />
ball.geom = dCreateSphere(space,ball.radius);<br />
dGeomSetBody(ball.geom,ball.body);</p>
<p>// fixed joint<br />
fixed[0] = dJointCreateFixed(world,0);<br />
dJointAttach(fixed[0],0, box.body);<br />
dJointSetFixed(fixed[0]);</p>
<p>fixed[1] = dJointCreateFixed(world,0);<br />
dJointAttach(fixed[1],stick.body,ball.body);<br />
dJointSetFixed(fixed[1]);</p>
<p>sensor = dJointCreateFixed(world,0);<br />
dJointAttach(sensor,box.body, stick.body);<br />
dJointSetFixed(sensor);</p>
<p>// set feed back<br />
dJointSetFeedback(sensor,feedback);</p>
<p>dsSimulationLoop(argc,argv,640, 480,&amp;fn);</p>
<p>dWorldDestroy(world);</p>
<p>return 0;<br />
}<br />
[/code]</p>
