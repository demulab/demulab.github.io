---
layout: post
title: ODE講座23：関節中心点の取得とスケルトン表示
date: 2007-11-11 12:52:43.000000000 +09:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- ode
tags: []
meta:
  _edit_last: '2'
  views: '2346'
author:
  login: demu
  email: info@demura.net
  display_name: demu
  first_name: ''
  last_name: ''
permalink: "/robot/9ode/461.html"
---
<p><a href="http://demura.net/cgi-bin/mt/#mce_temp_url#"><br />
<img title="Open Dynamics Engine" src="{{ site.baseurl }}/assets/images/2007/11/snake.jpg" alt="Open Dynamics Engine" width="400" height="328" /><br />
</a><br />
<span style="font-size: x-small;">上の図はジョイント（関節）の中心に球を描画し、各ボディの重心と各関節中心を直線で結び、それが外部から見えるようにボディを半透明にしスケルトン表示しています。</span></p>
<p>ODE (Open Dynamics Engine) 講座の２３回目です。 11月に入り、カニ漁が解禁になりました。雄のズワイガニはとても有名ですが、その雌は香箱ガニと呼ばれ体は小さいのですが、卵が美味で珍味として重宝されています。今年は豊漁のようで、金沢では近所のスーパーで３杯１０００円程度で購入できます。金沢では美味しい食べ物とお酒と温泉がこれからの楽しみとなります。</p>
<p>さて、チップさんから、関節中心点の取得法について質問があり、ODE本を読んでもよくわからないとのことだったのでここで補足します。</p>
<p><!--more--></p>
<p>この例では、関節の中心を球で表示し、重心と関節中心を線で表示しています。さらに、線が見えるようにボディを半透明にしています。 半透明で描画するAPIはdsSetColorAlphaです。</p>
<p><strong>1</strong><strong>.  関節中心点の取得</strong></p>
<p>ここでは関節としてヒンジジョイントを例に取ります。ヒンジジョイントの関節中心点を取得するAPIは次の２つあります。</p>
<ul>
<li><strong>d</strong><strong>JointGetHingeAnchor(  dJointID  joint, dVector3 result)</strong></li>
</ul>
<ul>
<li><strong>dJointGetHingeAnchor2(dJointID joint,  dVector3 result)</strong></li>
</ul>
<p>ヒンジジョイントjointの関節中心を絶対座標系で取得し、その値をresultに代入します。dVector3はdReal型の要素数３個の配列です。正確には要素数４個の配列ですが、これは計算を高速にするためのテクニックで、実際には最初の３個の要素しか使われません。</p>
<p>1番目と２番目のAPIの違いは前者はボディ１に対応するヒンジの中心点で、後者のdJointGetHingeAnchor2はボディ２に対応するヒンジの中心点です。ヒンジを生成したときは両者の中心点は一致していますが、シミュレーションを重ねる度にずれが生じます。それぞれを直すのがEFPパラメータです。</p>
<p><strong>2. スケルトン表示（半透明色の設定）</strong></p>
<p>シミュレーションによっては内部の構造を見せるためにスケルトン表示したい場合があります。描画ライブラリであるdrawstuffを使い半透明の物体を描画するには次のAPIを使います。</p>
<ul>
<li><strong>dsSetColorAlpha(float r, float g, float b, float alpha);</strong></li>
</ul>
<p>ここで、最初の引数　r,　g,　bは赤、緑、青の三原色、alphaは透明度を表し、0から1までの範囲を取り、透明度で0は透明、1は不透明です。</p>
<p>なお、スケルトン表示する場合は描画の順番が大切です。この例の場合は、まず不透明の骨に相当する直線を描画し、その後に半透明の関節やボディを描画します。この順番を間違えると表示されません。</p>
<p>関係部分のソースコードを以下に示します。<a href="http://demura.net/archives/images/ode/jointAnchor.tgz">全ソースコードはここから取得可能です。<br />
</a>サンプルプログラムではbキーを押すとボディ描画の表示を切り替えます。</p>
<hr />[code]<br />
static void simLoop (int pause)<br />
{</p>
<p>const dReal *pos[BODY_NUM],*R[BODY_NUM];<br />
dMatrix3 R1;<br />
dVector3 ap[BODY_NUM-1];          // 関節中心点　anchor point<br />
float    ar = 0.06;                           // 関節表示用球の半径　anchor radius</p>
<p>if (!pause) {<br />
if (steps++ &lt; 10) dBodyAddForce (leg[0].body, 0, 1.0, 0);<br />
for (int i = 0; i &lt; BODY_NUM-1; i++) 　control(i, joint[i]);<br />
dSpaceCollide(space,0,&amp;nearCallback);<br />
dWorldStep(world,0.01);<br />
dJointGroupEmpty(contactgroup);<br />
}</p>
<p>// 重心位置と回転行列の取得　calculate positions and orientaitons<br />
for (int i = 0; i &lt; BODY_NUM; i++) {<br />
pos[i] = dBodyGetPosition(leg[i].body);<br />
R[i]   = dBodyGetRotation(leg[i].body);<br />
}</p>
<p>// 関節中心の取得　　calculate anchor points<br />
dRSetIdentity(R1);<br />
for (int i = 0; i &lt; BODY_NUM-1; i++) {<br />
dJointGetHingeAnchor(joint[i], ap[i]);<br />
}</p>
<p>// 関節中心から重心まで直線で描画　draw lines<br />
for (int i = 0; i &lt; BODY_NUM-1; i++) {<br />
dsSetColorAlpha(1.3, 1.3, 1.3, 1.0);<br />
dsDrawLine(pos[i], ap[i]);<br />
dsSetColorAlpha(0.0, 0.0, 0.0, 1.0);<br />
dsDrawLine(ap[i],  pos[i+1]);<br />
}</p>
<p>dsSetColorAlpha(1.3, 0.0, 0.0, 0.5);<br />
// 関節中心を中心とした球の描画　draw anchors<br />
for (int i = 0; i &lt; BODY_NUM-1; i++) {<br />
dJointGetHingeAnchor(joint[i], ap[i]);　// 関節中心点の取得<br />
dsDrawSphere(ap[i], R1, ar);<br />
}</p>
<p>// ボディの描画　draw legs<br />
dsSetColorAlpha(0.0, 0.0, 1.3, 0.5);　// 透明色の設定<br />
for (int i = 0; i &lt; BODY_NUM; i++) {<br />
if (drawBody) dsDrawCapsule(pos[i],R[i],leg[i].length,leg[i].radius);<br />
}<br />
}</p>
<p>[/code]</p>
<hr />続く...</p>
