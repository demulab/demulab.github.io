---
layout: post
title: ODE講座24：AMOTORはエー(良い)モータ
date: 2008-01-16 10:38:57.000000000 +09:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- ode
tags: []
meta:
  _aioseop_keywords: amotor, ODE, open dynamics engine
  _edit_last: '2'
  views: '3050'
author:
  login: demu
  email: info@demura.net
  display_name: demu
  first_name: ''
  last_name: ''
permalink: "/robot/9ode/481.html"
---
<p><img src="{{ site.baseurl }}/assets/images/2008/01/amotor2.jpg" alt="AMOTOR" /><br />
<span>図：２リンク機構に初期角速度を与えるシミュレーション </span><br />
CohCohさんのご質問で初期の関節角速度の設定法がありましたので、久しぶりにODE(Open Dynamics Engine)講座を開講します。</p>
<p>ODEでは関節にモータが標準で付属していますが、関節角速度を設定しようとしても、目標角速度に到達するまで時間がかかりますし、その角速度を維持するためにはそれなりの制御が必要です。現実のモータを単純にモデル化したものです。</p>
<p>これでは、初期角速度を設定できません。この問題を解決する方法として、ODEには理想的なAMOTORがあります。マニュアルでは１ステップで目標角速度に到達するとありますが、関節に与える最大トルクdParamFmaxの値が0だと目標角速度に到達しません。また、小さな値の場合は、目標角速度に到達するまで数ステップかかることを確認しました。</p>
<p>そこで、十分大きな値を設定してください。以下のサンプルプログラムでは目標角速度dParamVelに無限大dInifinityを与えています。</p>
<p>また、初期角速度だけ与えたい場合は、角速度が目標値に到達したら、dJointDestroy()でamotorを破壊する必要があります。これを忘れると常に角速度は目標角速度のままです。amotorを破壊したくない場合は、dJointSetAMotorNumAxes(amotor, 0)で制御する軸数を０に設定し、無効化してもＯＫです。</p>
<p>次に、APIを紹介します。</p>
<p><!--more--></p>
<blockquote><p><strong>dJointID dJointCreateAMotor(dWorldID, dJointGroupID);</strong><br />
AMOTORの生成。</p>
<p><strong>void dJointSetAMotorMode(dJointID, int mode);</strong><br />
AMOTORのモード設定。modeはユーザが独自に設定するdAMotorUserまたは、自動的にオイラー角が計算されるdAMotorEulerの２つのモードがある。</p>
<p><strong>void dJointSetAMotorNumAxes(dJointID, int num);</strong><br />
AMOTORでコントロールされる軸数を設定する。numの値は0から3までで、0の場合はジョイントを無効化する。dAMotorEulerモードの場合は自動的に3が設定される。</p>
<p><strong>void dJointSetAMotorAxis (dJointID, int anum, int rel, dReal x, dReal y, dReal z);</strong><br />
AMOTORの回転軸を設定する。引数anumは変更する軸(0, 1, 2)、relは以下の相対回転モードを設定する。最後の(x,y,z)は回転軸ベクトル。</p>
<ul>
<li> 0: 軸は絶対座標系に固定</li>
<li> 1: 1番目のボディに固定</li>
<li> 2: 2番目のボディに固定</li>
</ul>
<p><strong>void dJointSetAMotorParam (dJointID, int parameter, dReal value);</strong><br />
AMOTORのパラメータを設定する。 parameterについては他のジョイントと同じ。この例では角速度（スライダージョイントの場合は速度）dParamVel、最大発揮トルクdParamFMaxを使用した。</p></blockquote>
<p>AMOTORはAngular Motorの略ですが、エー（良い）モータですね。ソースコードを以下に示しますので試してください。<br />
なお、簡単にするために衝突検出機能は実装されていません。<a href="http://demura.net/archives/images/ode/amotor2-080115.tgz">ここからダウンロード可能です(amotor2-080115.tgz)。</a><br />
[code]<br />
// 2008-1-15<br />
// amotor2.c: 2 Links with an amotor by Kosei Demura<br />
#include<br />
#include<br />
#include<br />
#include</p>
<p>#define NUM 2<br />
#ifdef dDOUBLE<br />
#define dsDrawCylinder dsDrawCylinderD<br />
#endif</p>
<p>dWorldID      world;<br />
dSpaceID      space;<br />
dGeomID       ground;<br />
dJointID      joint[NUM], amotor;<br />
dsFunctions fn;</p>
<p>typedef struct {<br />
dBodyID body;<br />
dGeomID geom;<br />
} MyLink;</p>
<p>MyLink rlink[NUM];</p>
<p>void  createArm()<br />
{<br />
dReal init_avel = 1.0; // 初期角速度[rad/s]<br />
dMass mass;<br />
dReal x[] = { 0.00, 0.00}, y[] = { 0.00, 0.00}, z[]= { 0.75 ,0.25}; // 重心<br />
dReal length[] = { 0.50, 0.50};   // リンク長<br />
dReal weight[] = { 1.00, 1.00};   // 質量<br />
dReal r[]        = { 0.02, 0.02}; // 半径<br />
dReal anchor_x[] = { 0.00, 0.00}; // 回転軸中心<br />
dReal anchor_y[] = { 0.00, 0.00};<br />
dReal anchor_z[] = { 1.00, 0.50};<br />
dReal axis_x[] = { 1.00, 1.00};   // 回転軸ベクトル<br />
dReal axis_y[] = { 0.00, 0.00};<br />
dReal axis_z[] = { 0.00, 0.00};</p>
<p>// リンクの生成<br />
for (int i = 0; i &lt; NUM; i++) {<br />
rlink[i].body = dBodyCreate(world);<br />
dBodySetPosition(rlink[i].body, x[i], y[i], z[i]);<br />
dMassSetZero(&amp;mass);<br />
dMassSetCylinderTotal(&amp;mass,weight[i],3,r[i],length[i]);<br />
dBodySetMass(rlink[i].body, &amp;mass);<br />
rlink[i].geom = dCreateCylinder(space,r[i],length[i]);<br />
dGeomSetBody(rlink[i].geom,rlink[i].body);<br />
}</p>
<p>//ジョイントの生成と結合<br />
for (int j = 0; j &lt; NUM; j++) {<br />
joint[j] = dJointCreateHinge(world, 0);</p>
<p>// リンク１はjoint[0]により静的環境0と結合<br />
if (j == 0) dJointAttach(joint[0], rlink[0].body, 0);<br />
else         dJointAttach(joint[j], rlink[j].body, rlink[j-1].body);<br />
dJointSetHingeAnchor(joint[j], anchor_x[j], anchor_y[j], anchor_z[j]);<br />
dJointSetHingeAxis(joint[j], axis_x[j], axis_y[j],axis_z[j]);<br />
}</p>
<p>// リンク1とリンク2を結合しているジョイントを可動域設定<br />
dJointSetHingeParam(joint[1], dParamLoStop, -0.0 * M_PI); // 可動域の下限<br />
dJointSetHingeParam(joint[1], dParamHiStop,  0.0 * M_PI); // 可動域の上限</p>
<p>// amotorの生成<br />
amotor = dJointCreateAMotor(world, 0);    // AMotorの生成<br />
dJointAttach(amotor, rlink[0].body, 0);   // AMotorとリンクとの結合<br />
dJointSetAMotorMode(amotor, dAMotorUser); // ユーザモードに設定、デフォルト、省略可<br />
dJointSetAMotorNumAxes(amotor, 1);        // AMotorでコントロールする軸数</p>
<p>// 軸の設定：回転軸0を絶対座標系に固定、回転軸ベクトルは(1, 0, 0)<br />
dJointSetAMotorAxis(amotor,	 0 /*軸0*/, 0 /*絶対座標系に固定*/, 1 /*x成分*/, 0 /*y成分*/, 0 /*z成分*/);</p>
<p>// amotorの設定, 初期角速度をinit_avelに設定<br />
dReal fmax = dInfinity;　// 無限大<br />
dJointSetAMotorParam(amotor, dParamVel, init_avel);<br />
dJointSetAMotorParam(amotor, dParamFMax, fmax);<br />
}</p>
<p>void drawLink()<br />
{<br />
dReal r,length;</p>
<p>for (int i = 0; i &lt; NUM; i++ ) {<br />
if (i == 1) dsSetColor(1.3, 1.3, 0.0);<br />
else        dsSetColor(0.0, 0.0, 1.3);<br />
dGeomCylinderGetParams(rlink[i].geom, &amp;r,&amp;length);<br />
dsDrawCylinder(dBodyGetPosition(rlink[i].body),<br />
dBodyGetRotation(rlink[i].body),length,r);<br />
}<br />
}</p>
<p>void start()<br />
{<br />
float xyz[3] = {  2,  0, 1};<br />
float hpr[3] = {-180, 0, 0.0};<br />
dsSetViewpoint(xyz,hpr);<br />
}</p>
<p>// 簡単にするため衝突検出は未実装<br />
void simLoop(int pause)<br />
{<br />
static int step = 0;</p>
<p>drawLink();<br />
const dReal ang_rate = dJointGetHingeAngleRate(joint[0]);<br />
printf("step=%4d: angle rate=%8.6f \n", step, ang_rate);<br />
dWorldStep(world, 0.001);</p>
<p>dReal k1 = 0.0; // 摩擦トルク用比例係数 負値を設定<br />
dJointAddHingeTorque(joint[0], k1 * ang_rate); // 摩擦トルクを付加</p>
<p>if (step == 0) dJointDestroy(amotor); // amotorの破壊<br />
// amotorを破壊したくない場合は以下でも良い<br />
// if (step == 0) dJointSetAMotorNumAxes(amotor, 0);</p>
<p>step++;<br />
}</p>
<p>void setDrawStuff() {<br />
fn.version = DS_VERSION;<br />
fn.start   = &amp;start;<br />
fn.step    = &amp;simLoop;<br />
fn.path_to_textures = "../../drawstuff/textures";<br />
}</p>
<p>int main(int argc, char *argv[])<br />
{<br />
setDrawStuff();<br />
world = dWorldCreate();<br />
space = dHashSpaceCreate(0);<br />
// dWorldSetGravity (world, 0, 0, -9.8); // 重力加速度<br />
createArm();<br />
dsSimulationLoop(argc,argv,640, 480,&amp;fn);<br />
dSpaceDestroy(space);<br />
dWorldDestroy(world);<br />
return 0;<br />
}<br />
[/code]</p>
<p>終わり。</p>
