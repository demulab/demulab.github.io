---
layout: post
title: ODE講座6補講：衝突検出
date: 2008-01-25 09:42:44.000000000 +09:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- ode
tags: []
meta:
  _edit_last: '2'
  views: '1908'
author:
  login: demu
  email: info@demura.net
  display_name: demu
  first_name: ''
  last_name: ''
permalink: "/robot/9ode/482.html"
---
<p><img src="{{ site.baseurl }}/assets/images/2008/01/sample2.jpg" alt=" " width="280" height="269" /><br />
ODE講座6のソースコードでは地面と球との接触を判定する変数をグローバル変数としていました。授業ではグローバル変数の使用を避けるように説明しているので、ソースコードをローカル変数に改めましょう。今年度からプログラミングの講義にODEを使い、学生のモチベーションとプログラミングスキルを高めるという試みをしているので、今回の補講はその一環です。</p>
<p>ポイントは<strong>dSpaceCollide(dSpaceID space, void ＊data, dNearCallback ＊callback);</strong>がcallback関数に引数dataを渡すことができるので、そのdataとして衝突判定の変数を渡すことです。なお、dataはvoidへのポインタになっています。<strong>void ＊</strong>は<strong>汎用ポインタ</strong>と呼ばれるもので、関数の引数として色々な型を取ることができる万能選手です。</p>
<p>注意する点としては、次のソースコード４行目のように使いたい型にキャストすることです。</p>
<p><!--more--><br />
[code]<br />
// 　衝突検出のコールバック関数<br />
static void nearCallback(void *data, dGeomID o1, dGeomID o2)<br />
{<br />
int *flag = (int *) data;     // 汎用ポインタは使いたい型にキャストが必要<br />
static const int N = 4;　　　　// 接触点数の上限は4個  staticを忘れずにつけてください．</p>
<p>dContact contact[N];</p>
<p>int isGround = ((ground == o1) || (ground == o2));　// 衝突する２つのうちどちらかが地面ならisGroundのフラグを立てる<br />
int n =  dCollide(o1,o2,N,&amp;contact[0].geom,sizeof(dContact));　// nは衝突点数</p>
<p>if (isGround)  {　// 衝突する可能性のあるジオメトリのどちらかが地面なら<br />
if (n &gt;= 1) *flag = 1; // 変更した部分<br />
else        *flag = 0; // 変更した部分<br />
for (int i = 0; i &lt; n; i++) {<br />
contact[i].surface.mode = dContactBounce;　// 地面の反発係数を設定<br />
contact[i].surface.bounce = 0.0; // (0.0~1.0)   反発係数は0から1まで<br />
contact[i].surface.bounce_vel = 0.0; // (0.0以上)   反発に必要な最低速度</p>
<p>// コンタクトジョイント生成<br />
dJointID c = dJointCreateContact(world,contactgroup,&amp;contact[i]);<br />
// 接触している２つのgeometryをコンタクトジョイントで拘束<br />
dJointAttach (c,dGeomGetBody(contact[i].geom.g1),<br />
dGeomGetBody(contact[i].geom.g2));<br />
}<br />
}<br />
}</p>
<p>static void simLoop (int pause)<br />
{<br />
const dReal *pos,*R;<br />
int flag = 0;     // 地面との衝突flagを０にセット</p>
<p>// 衝突判定、flagのアドレスがnearCallback関数に引数として渡される。<br />
// この例では地面と衝突するとflagに１、衝突しない場合は０が入る。<br />
dSpaceCollide(space, &amp;flag,&amp;nearCallback);</p>
<p>dWorldStep(world,0.01);　　　　　           // シミュレーションを1ステップ進める<br />
dJointGroupEmpty(contactgroup);        // ジョイントグループを空にする</p>
<p>if (flag == 0) dsSetColor(1.0, 0.0, 0.0);　 // 赤色の設定<br />
else             dsSetColor(0.0, 0.0, 1.0);  //  青色の設定<br />
pos = dBodyGetPosition(ball.body);　      // 位置<br />
R   = dBodyGetRotation(ball.body);　      // 回転行列<br />
dsDrawSphere(pos,R,radius);　　          　// 球の描画<br />
}<br />
[/code]</p>
<p>今回はこの辺で…</p>
