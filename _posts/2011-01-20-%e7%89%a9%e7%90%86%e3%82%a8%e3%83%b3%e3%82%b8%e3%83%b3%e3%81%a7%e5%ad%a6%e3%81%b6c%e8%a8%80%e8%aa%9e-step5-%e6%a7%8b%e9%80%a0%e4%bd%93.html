---
layout: post
title: '物理エンジンで学ぶC言語 [STEP5: 構造体]'
date: 2011-01-20 18:17:50.000000000 +09:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- ode
tags: []
meta:
  _edit_last: '2'
  views: '1032'
  _wp_old_slug: ''
author:
  login: demu
  email: info@demura.net
  display_name: demu
  first_name: ''
  last_name: ''
permalink: "/robot/9ode/8462.html"
---
<p>[caption id="attachment_7525" align="aligncenter" width="612" caption="Step5サンプルプログラム：ドミノ倒し"]<a href="http://demura.net/wordpress/wp-content/uploads/2010/07/domino.jpg"><img src="{{ site.baseurl }}/assets/images/2011/01/domino.jpg" alt="domino" title="domino" width="612" height="450" class="size-full wp-image-7525" /></a>[/caption]</p>
<p>ODEで学ぶC言語2のStep5です．今回は構造体と物体へ力やトルクを加える方法，さらにシミュレーションのリセット法などを学びます．構造体の概要については既にわかっているものとし，サンプルコードを示すことにより具体的な使い方を学びます．</p>
<p><!--more--></p>
<p><strong>○　構造体</strong></p>
<p>配列では同じ型しかまとめることができませんでしたが，構造体では違う型をまとめて扱うことができるのでシミュレーションなど物体に多くの属性がある場合に便利です．このサンプルプログラムでは物体をdmObjectという構造体で次のように表しています．dm5.hの１６行目に定義しています．今回の例はドミノ倒しなので，この構造体を元にドミノを21個生成しています．</p>
<pre class="brush:cpp;">typedef struct{
    dBodyID body; // ボディのID
    dGeomID geom; // ジオメトリのID
    const double *p; // x, y, z　&#91;m&#93;
    const double *R;   // 回転行列 要素数4x3
    double m; // 質量 &#91;kg&#93;
    double r,l; // 半径 &#91;m&#93;, 長さ &#91;m&#93;
    const double *side; // サイズ　x,y,z
    const double *color; // 色 r,g,b
} dmObject;</pre>
<p>また、STEP4まではdmLoop関数の引数にstep関数やcommand関数を渡していましたが、ここでは関数のポインタを要素に持つ構造体dmFunctionsを定義します。今まではdmLoopに渡す関数が増えるとその数だけ引数が多くなってしまいましたが、この構造体だけを引数として渡せば良いのでプログラムがすっきりします。</p>
<pre class="brush:cpp;">typedef struct
{
    void (*start)();            // 初期化関数
    void (*step) (int pause);	// ステップ関数
    void (*command) (int cmd);	// キー関数
} dmFunctions;</pre>
<p>○<strong> 姿勢の変更</strong></p>
<p>物体の姿勢を変更するためには次のAPIを使い回転行列Rの値を変更します．ここで，Rは回転行列が格納されている配列へのポインタ，ax, ay, axは回転軸ベクトル．angleは回転角度となります．なお，dだけで始まるAPIはODEのAPIです．</p>
<ul>
<li><strong>dRFromAxisAndAngle(double　R[12], double  ax, doulbe  ay, double  az, double angle);</strong></li>
</ul>
<p><strong>○　力，トルクの加え方</strong></p>
<ul>
<li><strong>void dmAddForce(dmObject *obj, double fx, double fy, double fz)</strong>
<ul>
<li>物体objの重心に力(fx,fy,fz)を加える</li>
</ul>
</li>
<li><strong>void dmAddTorque(dmObject *obj, double fx, double fy, double fz)</strong>
<ul>
<li>物体objの重心にトルク(fx, fy, fz)を加える．fx，ｆｙ，ｆｚはそれぞれx, y, z軸まわりのトルク</li>
</ul>
</li>
</ul>
<p>○　<strong>高速なシミュレーション</strong></p>
<p>前回のサンプルではシミュレーションのステップ関数としてdmWorldStep()を使いましたが，ここではより高速なdmWorldQuickStep()を使います．ただし，dmWorldStep()と比較して精度が悪くなります．</p>
<p><strong>○　シミュレーションのリセット</strong></p>
<p>rまたはRキーを押すと，resetSim関数が呼ばれてシミュレーションがリセットされます．resetSimの中身はシミュレーションループが１回以上呼び出されたときにdmInit関数を呼び出して初期化し，ドミノを再度生成しています．</p>
<p><strong>○　ソースコード</strong></p>
<pre class="brush:cpp;">/* step5 ドミノ倒し 2011-01-20 　*/
#include "dm5.h"
#define DOMINO_NUM  21

static int STEPS = 0;   // シミュレーションのステップ数
double red&#91;3&#93; = {1.3, 0.0, 0.0}; // 赤色
dmObject domino&#91;DOMINO_NUM&#93;; // ドミノ
dmFunctions dmf; // 描画関数の構造体

/***  シミュレーションループ　***/
void simLoop(int pause)
{
    int i;

    dmWorldQuickStep(); // シミュレーションを１ステップ進める(高速版)

    for (i = 0; i &#60; DOMINO_NUM; i++)
    {
        dmDraw(&amp;domino&#91;i&#93;); //　壁の描画
    }
    STEPS++;
}

void resetSim(int n)
{
    double m = 0.1; // 質量
    double side&#91;3&#93; = {0.2, 0.05, 0.5}; // サイズ
    double R&#91;12&#93; = {1,0,0,0, 0,1,0,0, 0,0,1,0}; // 姿勢
    double p&#91;DOMINO_NUM&#93;&#91;3&#93;;  // 位置

    int i;

    // シミュレーションの終了
    if (STEPS != 0)
    {
        dmClose();
    }

    dmInit(); // 初期化

    // ドミノの生成
    for (i = 0; i &#60; DOMINO_NUM; i++)
    {
        p&#91;i&#93;&#91;2&#93; = 0.25; // ドミノ重心のz座標
        switch (n)
        {
        case 0:
            p&#91;i&#93;&#91;0&#93; = 0;             // ドミノ重心のx座標
            p&#91;i&#93;&#91;1&#93; = 0.3 * i -3.0;  // ドミノ重心のy座標
            break;
        case 1:
            p&#91;i&#93;&#91;0&#93; = 0.3 * i -3.0;
            p&#91;i&#93;&#91;1&#93; = p&#91;i&#93;&#91;0&#93;;
            // z軸周りにπ/4回転させた姿勢
            dRFromAxisAndAngle(R, 0, 0, 1, - M_PI/4);
            break;
        default:
            printf("Bad number \n");
            break;
        }
        dmCreateBox(&amp;domino&#91;i&#93;, p&#91;i&#93;, R, m, side, red);
    }
}

/*** キ―入力関数 ***/
void command(int cmd)
{
    switch (cmd)
    {
    case '1':
        resetSim(1);
        break;
    case 'r':
    case 'R':
        resetSim(0);
        break;
    case 'f':
    case 'F':
    {
        double fx = -1.0, fy = 0.0, fz = 0.0;
        dmAddTorque(&amp;domino&#91;0&#93;, fx, fy, fz); // x,y,z軸まわりにfx,fy,fzのトルクを付加
        break;
    }
    default:
        printf("Input r, R, f, F key \n");
        break;
    }
}

/*** カメラの位置と姿勢設定 ***/
void setCamera()
{
    float x = 5.0, y = 0.0, z = 1.0;    // カメラの位置
    float roll = 0, pitch = 0, yaw = -180; // カメラの方向&#91;°&#93;
    dmSetCamera(x,y,z,roll,pitch,yaw);  // カメラの設定
}

/*** 描画用構造体の設定　***/
void setDraw()
{
    dmf.start   = &amp;setCamera;
    dmf.step    = &amp;simLoop;
    dmf.command = &amp;command;
}

/*** main関数 ***/
int main()
{
    resetSim(0); // シミュレーションのリセット
    setDraw();   // 描画関数の設定

    dmLoop(800, 600, &amp;dmf);  // ウインドウの幅，高, ループ関数，コマンド関数
    dmClose(); // 終了

    return 0;
}</pre>
<p><strong>ホームワーク</strong></p>
<ol>
<li><a href="http://demura.net/wordpress/wp-content/uploads/2011/01/step5-110120a.zip">サンプルコードをここからダウンロードして実行しよう．</a></li>
<li>１０００ステップ経過したら自動的にドミノが立ち上がるようにプログラムを変更しなさい。</li>
<li>１０００ステップ毎にドミノ倒しが無限に続くようにプログラムを変更しなさい。</li>
<li>ドミノを１辺６ｍの正方形上に配置して、ドミノ倒しをしなさい。</li>
<li>ドミノを半径３ｍの円上に配置して、ドミノ倒しをしなさい。</li>
</ol>
