---
layout: post
title: 物理エンジンODEで学ぶC言語[Step3:関数]
date: 2014-07-03 07:20:24.000000000 +09:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- ode
tags: []
meta:
  _edit_last: '2'
  views: '1028'
author:
  login: demu
  email: info@demura.net
  display_name: demu
  first_name: ''
  last_name: ''
permalink: "/robot/9ode/10909.html"
---
<p><a href="http://demura.net/wordpress/wp-content/uploads/2014/07/step3.jpg"><img src="{{ site.baseurl }}/assets/images/2014/07/step3-300x242.jpg" alt="step3" width="300" height="242" class="aligncenter size-medium wp-image-10911" /></a></p>
<p>ODEで学ぶC言語の３回目です．ODEの物理計算の部分は使わず，drawstuffを使った表示だけにします．<br />
今回は今まで演習で作ったコードを整理して関数化しています．</p>
<p>まず，116行目のsimLoop関数から説明します．ここはシミュレーションで毎回呼び出される関数です．118行目のcollision関数でブロックが他のブロックと衝突しているかどうかの判定を行っています。衝突したら1を返し，それ以外は0を返します．衝突したら，新しいブロックを生成するためにnowを１増加させ，ブロックの位置を初期化しています．<br />
122行目はブロックを表示し，123行目で壁を表示しています．<br />
<!--more--><br />
45行目のキー入力処理をするcommand関数では，ブロックを動かすa, dキーだけにしています．</p>
<p>61行目のdrawField関数ではフィールドを表示しています．ここでは，今後の処理のために，19行目にフィールドを表す，2次元配列mazeを宣言，初期化しています．要素１は壁，０は何もないことを示します．</p>
<p>80行目のinitBlock関数で，新しく生成したブロックの初期位置を設定しています．</p>
<p>109行目のcolllision関数は，未実装で演習問題になっています．現在，操作可能なブロックと他のブロックの距離を計算し，1[m]より小さい場合にブロック同士が衝突したと判定し１を返し，それ以外は０を返します．</p>
<p>説明はこのぐらいにして，ソースコードを読んで演習をしましょう．</p>
<pre class="brush:cpp;">/* step3 　2013-07-03 　*/
#include "dm3.h"
#include &#60;time.h&#62;
#include &#60;stdlib.h&#62;

#define ROW       22  // フィールドの行数
#define COLUMN 11  // フィールドの列数

double R&#91;12&#93; = {1,0,0,0, 0,1,0,0, 0,0,1,0}; // 回転行列が格納される配列, 位置(x,y,z)&#91;m&#93;
double start_x =  5.5, start_y = 0.5, start_z = 0.0; // 壁の初期位置
double start_bx = 10.5, start_by = 20.5, start_bz = 0.5; // ブロックの初期位置

double wall_p&#91;3&#93; = {0.0, 0.0, 0.5};   // 壁の位置(x,y,z)&#91;m&#93;
double block_p&#91;100&#93;&#91;3&#93;; // ロボットの位置
double sides&#91;3&#93; = {1.0, 1.0, 1.0}; // 直方体のサイズ(x, y, z)&#91;m&#93;
float black&#91;3&#93; = {0, 0, 0}, green&#91;3&#93; = {0,1,0},red&#91;3&#93; = {1,0,0}; // 黒色，緑色，赤色
int       now = 0; // 現在、操作可能なブロック番号

int field&#91;ROW&#93;&#91;COLUMN&#93; =  // フィールド
{
    {1,1,1,1,1,1,1,1,1,1,1},
    {1,0,0,0,0,0,0,0,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,1},
    {1,1,1,1,1,1,1,1,1,1,1} 
};

void command(int cmd)
{
    switch (cmd)
    {
    case 'a':
        if (block_p&#91;now&#93;&#91;0&#93; &#62; 1.5)  block_p&#91;now&#93;&#91;0&#93; -= 1.0;
        break;
    case 'd':
        if (block_p&#91;now&#93;&#91;0&#93; &#60; 18.5) block_p&#91;now&#93;&#91;0&#93; += 1.0;
        break;
    default:
        printf("Key is %c: Input a,d,w,x,r\n",(char)cmd);
    }
}

// フィールドの描画
void drawField()
{
    int i, j;
    for (i = 0; i &#60; ROW; i++)
    {
        for (j = 0; j &#60; COLUMN; j++)
        {
            if (field&#91;i&#93;&#91;j&#93; == 1)
            {
                dsSetColor(1.0, 0.0, 0.0); // 色の設定
                wall_p&#91;0&#93; = j  + start_x;       // 位置のx成分
                wall_p&#91;1&#93; = i  + start_y;       // 位置のx成分
                wall_p&#91;2&#93; = 0.5;                 // 位置のz成分
                dsDrawBox(wall_p,R,sides); // 直方体の表示
            }
        }
    }
}

// ブロックの初期化
void initBlock()
{
    block_p&#91;now&#93;&#91;0&#93; = start_bx;
    block_p&#91;now&#93;&#91;1&#93; = start_by;
    block_p&#91;now&#93;&#91;2&#93; = start_bz;
}

// ブロックの描画
void drawBlock()
{
    int i;

    if (block_p&#91;now&#93;&#91;1&#93; &#62;1.5)   // 下の壁を突き抜けない
    {
        block_p&#91;now&#93;&#91;1&#93; -= 0.1; // ブロックの落下
    }
    else
    {
        now++;
        initBlock();
    }
    dsSetColor(1.0, 1.0, 0.0);   // 黄色

    for (i=0; i &#60;= now; i++)
        dsDrawSphere(block_p&#91;i&#93;, R, 0.5);
}

// ブロックが他のブロックと衝突したら１を返す，それ以外は０を返す
int collision()
{
    //　ブロック間の距離が１未満なら１を返すコードを
    //  ここに書きなさい
     return 0;
}

void simLoop(int pause)        /***  シミュレーションループ　***/
{
    if (collision()) {
        now++;
        initBlock();
    }
    drawBlock(); // ブロックの表示
    drawField();   // フィールドの表示
}

int main()         /*** main関数 ***/
{
    initBlock();
    srand(time(NULL)); // 乱数の初期化
    dmLoop(800, 600); // シミュレーションループ ウインドウの幅，高
    return 0;
}
</pre>
<p>では，演習をしながら落ち物系パズルゲームを作っていきましょう．</p>
<p>演習</p>
<ol>
<li><a href="http://demura.net/wordpress/wp-content/uploads/2014/07/step3-140702.zip">step3-140702</a>をダウンロードし，実行してください．</li>
<li>collision関数を実装して，実行してください．</li>
<li>落ちるブロックの色を変更してください．</li>
<li>ブロックが各行一杯になったら，その行のブロックを全て消すようにするためにはどうすればよいでしょうか．</li>
</ol>
