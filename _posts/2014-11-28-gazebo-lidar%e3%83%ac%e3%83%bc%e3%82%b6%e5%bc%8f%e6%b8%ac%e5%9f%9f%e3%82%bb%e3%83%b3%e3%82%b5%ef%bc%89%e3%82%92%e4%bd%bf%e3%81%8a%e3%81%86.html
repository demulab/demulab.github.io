---
layout: post
title: 'GAZEBO: レーザ式測域センサを使おう！'
date: 2014-11-28 07:04:31.000000000 +09:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- lecture
tags: []
meta:
  _edit_last: '2'
  _oembed_e0ea45b7bb8bcd92e0f8d9b5e536ebf0: "{{unknown}}"
  views: '4517'
  _oembed_851008643c64bb01c00dd98af24507f4: "{{unknown}}"
  _oembed_4ba85931eb4093977da342228a812137: "{{unknown}}"
  _oembed_c938055f7c09a9169aaf46bb799aa36a: "{{unknown}}"
  _oembed_8dc168b5dd8e63433541a94564204a15: "{{unknown}}"
  _oembed_b2f838cadee1f2d7bed57a4bb3f783ae: "{{unknown}}"
  _oembed_85b798802e4ba3009258dd27afa880ab: "{{unknown}}"
  _oembed_d2616e1cd0d4585c392c19a2f4b7112d: "{{unknown}}"
author:
  login: demu
  email: info@demura.net
  display_name: demu
  first_name: ''
  last_name: ''
permalink: "/education/lecture/11411.html"
---
<p>この記事が私が担当しているロボットプログラミングⅡの講義用です。</p>
<p>今回は前回作成した車輪型ロボットモデルに北陽電機のLIDAR（レーザ式測域センサ）モデルを搭載して動かしましょう。<br />
　なお、本記事は以下のGAZEBO.orgのチュートリアルを改変しています。<br />
http://wiki.gazebosim.org/wiki/Tutorials/1.2/control_robot/mobile_base_laser<br />
コードが古くgazebo4.0に対応していない部分を変更し、ワールド座標系での位置、姿勢の取得に関するコードを追加し、コメントを日本語化しています。それ以外のソースコードはほとんど同じものです。本ソースコードはgazebo4.0用なので、それ以前のバージョンでは動かないかもしれません。</p>
<p>1. 作業ディレクトリの作成<br />
端末を開き、以下のコマンドを実行する（$は打ち込まない）。ロボットプログラミングの演習では~/prog2ディレクトリ（フォルダ）の中にいろいろなプログラムを作っていく。<br />
<code><br />
$ mkdir -p ~/prog2/5sensor<br />
$ cd ~/prog2/5sensor<br />
$ gedit sensor.cc<br />
</code></p>
<p>2. ソースコードの作成<br />
プラグインとなるC++言語のソースコード(拡張子cc)を作成する。</p>
<p>以下のプログラムを「1.作業ディレクトリの作成」で開いたgedit（エディター）に次のソースコードをコピペしてwheel.ccを保存する。<br />
<span style="color: #ff0000;">　注：コピペするときは、下プログラムの右上にあるプリンタアイコンの左にあるView Sourceアイコンをクリックして、ソースを表示して、それをコピペすること。そうしないと、コンパイルと時のエラーになやまされることになる。</span></p>
<pre class="brush:cpp;">
//http://wiki.gazebosim.org/wiki/Tutorials/1.2/control_robot/mobile_base_laserを改変
#include &#60;boost/bind.hpp&#62;
#include &#60;gazebo/gazebo.hh&#62;
#include &#60;gazebo/physics/physics.hh&#62;
#include &#60;gazebo/sensors/sensors.hh&#62;
#include &#60;gazebo/common/common.hh&#62;
#include &#60;gazebo/transport/TransportTypes.hh&#62;
#include &#60;gazebo/msgs/MessageTypes.hh&#62;
#include &#60;gazebo/common/Time.hh&#62;
#include &#60;stdio.h&#62;

namespace gazebo
{
class MobileBasePlugin : public ModelPlugin
{
public:
    void Load(physics::ModelPtr _parent, sdf::ElementPtr _sdf)
    {
        // modelへポインタを格納
        this-&#62;model = _parent;

        // このプラグイン用のパラメータをロード
        if (this-&#62;LoadParams(_sdf))
        {
            // エラーチェック
            gzerr &#60;&#60; this-&#62;leftWheelJoint-&#62;GetAngle(0) &#60;&#60; "\n";
            gzerr &#60;&#60; this-&#62;rightWheelJoint-&#62;GetAngle(0) &#60;&#60; "\n";
            // アップテートイベントを聞く。シミュレーションの繰り返し時に
            // このイベントはブロードキャストされる。
            this-&#62;updateConnection
            = event::Events::ConnectWorldUpdateBegin(
                  boost::bind(&MobileBasePlugin::OnUpdate, this));
        }
    }

public:
    bool LoadParams(sdf::ElementPtr _sdf)
    {
        // 制御用のgainパラメータを見つける
        if (!_sdf-&#62;HasElement("gain"))
        {
            gzerr &#60;&#60; "param &#91;gain&#93; not found\n";
            return false;
        }
        else
        {
            // gainの値を取得
            this-&#62;gain = _sdf-&#62;Get&#60;double&#62;("gain");
        }

        // プラグインパラメータからセンサ名を見つける
        if (!_sdf-&#62;HasElement("ray_sensor"))
        {
            gzerr &#60;&#60; "param &#91;ray_sensor&#93; not found\n";
            return false;
        }
        else
        {
            // センサ名の取得
            std::string sensorName
            = _sdf-&#62;Get&#60;std::string&#62;("ray_sensor");

            // SensorMangaerを使い、センサのポインタを取得
            sensors::SensorPtr sensor
            = sensors::SensorManager::Instance()-&#62;GetSensor(sensorName);

            if (!sensor)
            {
                gzerr&#60;&#60; "sensor by name &#91;" &#60;&#60; sensorName
                &#60;&#60; "&#93; not found in model\n";
                return false;
            }

            this-&#62;laser = boost::shared_dynamic_cast&#60;sensors::RaySensor&#62;(sensor);
            if (!this-&#62;laser)
            {
                gzerr &#60;&#60; "laser by name &#91;"
                &#60;&#60; sensorName
                &#60;&#60; "&#93; not found in model\n";
                return false;
            }
        }

        // プラグインパラメーターからジョイントをロード
        if (!this-&#62;FindJointByParam(_sdf, this-&#62;leftWheelJoint,
                                    "left_wheel_hinge") ||
                !this-&#62;FindJointByParam(_sdf, this-&#62;rightWheelJoint,
                                        "right_wheel_hinge"))
            return false;

        // 成功時
        return true;
    }

public:
    bool FindJointByParam(sdf::ElementPtr _sdf,
                          physics::JointPtr &_joint,std::string _param)
    {
        if (!_sdf-&#62;HasElement(_param))
        {
            gzerr &#60;&#60; "param &#91;" &#60;&#60; _param &#60;&#60; "&#93; not found\n";
            return false;
        }
        else
        {
            _joint
            = this-&#62;model-&#62;GetJoint(_sdf-&#62;Get&#60;std::string&#62;(_param));

            if (!_joint)
            {
                gzerr &#60;&#60; "joint by name &#91;"
                &#60;&#60; _sdf-&#62;Get&#60;std::string&#62;(_param)
                &#60;&#60; "&#93; not found in model\n";
                return false;
            }
        }
        return true;
    }

    // ワールド更新開始イベントから呼び出される
public:
    void OnUpdate()
    {
        // ワールド座標系での位置と姿勢を取得
        math::Pose pose = this-&#62;model-&#62;GetWorldPose();
        printf("x=%.1f y=%.1f z=%.1f\n", pose.pos.x,pose.pos.y,pose.pos.z);
        printf("roll=%f pitch=%f yaw=%f\n",pose.rot.GetRoll(),pose.rot.GetPitch(),pose.rot.GetYaw());

        unsigned int n = this-&#62;laser-&#62;GetRangeCount();
        double min_dist = 1e6;
        for (unsigned int i = 0; i &#60; n; ++i)
        {
            if (this-&#62;laser-&#62;GetRange(i) &#60; min_dist)
                min_dist = this-&#62;laser-&#62;GetRange(i);
        }

        double target_dist = 2.0;
        if (min_dist &#60; this-&#62;laser-&#62;GetRangeMax())
        {
            // 比例制御
            double torque = this-&#62;gain*(min_dist - target_dist );
            this-&#62;leftWheelJoint-&#62;SetForce(0,  torque);
            this-&#62;rightWheelJoint-&#62;SetForce(0, torque);
        }
        else
        {
            this-&#62;leftWheelJoint-&#62;SetForce(0, 0);
            this-&#62;rightWheelJoint-&#62;SetForce(0, 0);
        }
    }

    // モデルへのポインタ
private:
    physics::ModelPtr model;
private:
    physics::WorldPtr world;

    // ワールド状態のサブスクライブ(講読)
private:
    transport::NodePtr node;
private:
    transport::SubscriberPtr statsSub;
private:
    common::Time simTime;

    // 更新イベントコネクションへのポインタ
private:
    event::ConnectionPtr updateConnection;
private:
    physics::JointPtr leftWheelJoint;
private:
    physics::JointPtr rightWheelJoint;
private:
    sensors::RaySensorPtr laser;
private:
    double gain;
};

// シミュレータへのプラグイン登録
GZ_REGISTER_MODEL_PLUGIN(MobileBasePlugin)
}
</pre>
<p>コピペしたらgeditの「保存」ボタンをクリックして~/prog2/5hello/の中に保存し、geditメニューバーの「ファイル(F)」→「終了(Q)」でgeditを終了する。</p>
<p>3. コンパイル設定ファイルの作成<br />
gazeboではソースコードをコンパイル(ビルド）するのにcmakeというシステムを使う。先程から使っている端末で以下のコマンドを実行しgeditを起動する。<br />
<code><br />
$ gedit CMakeLists.txt<br />
</code><br />
CMakeLists.txtはcmakeの設定ファイル。次の<span style="color: #ff0000;">ソースコード（２番の注参照）</span>をgeditにコピペし、CMakeLists.txtを保存する。保存場所は今までと同じ~/prog2/4wheelディレクトリ。保存したらgeditを終了する。</p>
<pre class="brush:cpp;">
cmake_minimum_required(VERSION 2.8 FATAL_ERROR)

find_package(Boost REQUIRED COMPONENTS system)
include_directories(${Boost_INCLUDE_DIRS})
link_directories(${Boost_LIBRARY_DIRS})

include (FindPkgConfig)
if (PKG_CONFIG_FOUND)
  pkg_check_modules(GAZEBO gazebo)
endif()
include_directories(${GAZEBO_INCLUDE_DIRS})
link_directories(${GAZEBO_LIBRARY_DIRS})

add_library(sensor SHARED sensor.cc)
target_link_libraries(sensor ${GAZEBO_LIBRARIES} ${Boost_LIBRARIES})
</pre>
<p>4．コンパイル<br />
以下のコマンドを実行し、ソースコードをメイクする。<br />
<code><br />
$ cd  ~/prog2/5sensor<br />
$ mkdir build<br />
$ cd build<br />
$ cmake ../<br />
$ make<br />
</code></p>
<p>5. モデルファイルのコピー<br />
(1) 以下のコマンドを実行し、モデルファイルをコピーする。<br />
<code><br />
$ cd  ~/.gazebo/models<br />
$ cp -r wheel_robot1 wheel_robot3<br />
</code></p>
<p>(2) model.configファイルの変更<br />
model.configの３行目</p>
<pre class="brush:cpp;">
&#60;name&#62;Wheel Robot 1 &#60;/name&#62;
</pre>
<p>を</p>
<pre class="brush:cpp;">
&#60;name&#62;Wheel Robot 3 &#60;/name&#62;
</pre>
<p>に変更する。</p>
<p>(3) model.sdfファイルへのプラグイン追加<br />
model.sdfの下から2行目にある＜／ｍｏｄｅｌ＞の上に以下のLIDARセンサとプラグインに関するコードを追加する。追加しないとロボットが動きません。</p>
<pre class="brush:cpp;">
    &#60;include&#62;
      &#60;uri&#62;model://hokuyo&#60;/uri&#62;
      &#60;pose&#62;0.175 0 0.3 0 0 0&#60;/pose&#62;
    &#60;/include&#62;
    &#60;joint name="hokuyo_joint" type="revolute"&#62;
      &#60;child&#62;hokuyo::link&#60;/child&#62;
      &#60;parent&#62;chassis&#60;/parent&#62;
      &#60;axis&#62;
        &#60;xyz&#62;0 0 1&#60;/xyz&#62;
        &#60;limit&#62;
          &#60;upper&#62;0&#60;/upper&#62;
          &#60;lower&#62;0&#60;/lower&#62;
        &#60;/limit&#62;
      &#60;/axis&#62;
    &#60;/joint&#62; 

    &#60;plugin name="sensor" filename="libsensor.so" &#62;
      &#60;left_wheel_hinge&#62;left_wheel_hinge&#60;/left_wheel_hinge&#62;
      &#60;right_wheel_hinge&#62;right_wheel_hinge&#60;/right_wheel_hinge&#62;
      &#60;gain&#62;0.1&#60;/gain&#62;
      &#60;ray_sensor&#62;laser&#60;/ray_sensor&#62;
    &#60;/plugin&#62;
</pre>
<p>6. 実行<br />
以下のコマンドを実行し、gazeboを立ち上げよう！ ここでは、gazeboを起動するのに--verboseのオプションをつけます。これは、標準出力に位置や姿勢を表示するためです。</p>
<p>gazeboが起動したら画面左側のinsert(挿入)タブから制作したwheel robot 3を選択する。ロボットの前に直方体と置くとロボットが動き出したら成功。今回はここまで。<br />
<code><br />
$ export GAZEBO_PLUGIN_PATH=~/prog2/5sensor/build:$GAZEBO_PLUGIN_PATH<br />
$ gazebo --verbose<br />
</code></p>
<p>○　演習<br />
LIDARを搭載した家政婦ロボットを動かしてみましょう。今回はロボットの後ろ5mに球を置き、それを見つけ、ドリブル（押し続ける）するプログラムを作ろう！ロボットサッカーのもっとも基本的なスキルです。</p>
<p><a href="http://demura.net/wordpress/wp-content/uploads/2014/11/sensor.jpg"><img src="{{ site.baseurl }}/assets/images/2014/11/sensor-300x202.jpg" alt="gazebo  lidar" width="600" height="404" class="aligncenter size-medium wp-image-11413" /></a></p>
