---
layout: post
title: 物理エンジンODEで学ぶC言語2015[STEP3:関数]
date: 2015-07-01 19:41:08.000000000 +09:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- ode
tags: []
meta:
  _edit_last: '2'
  views: '764'
author:
  login: demu
  email: info@demura.net
  display_name: demu
  first_name: ''
  last_name: ''
permalink: "/robot/9ode/11923.html"
---
<p><a href="http://demura.net/wordpress/wp-content/uploads/2015/07/step3.jpg"><img src="{{ site.baseurl }}/assets/images/2015/07/step3-300x242.jpg" alt="step3" width="300" height="242" class="aligncenter size-medium wp-image-11925" /></a></p>
<p>ODEで学ぶC言語の３回目です．ODEの物理計算の部分は使わず，drawstuffを使った表示だけにします．今回は今まで演習で作ったコードを整理して関数化しています．</p>
<p>まず，76行目のsimLoop関数から説明します．ここはシミュレーションで毎回呼び出される関数です．67行目のcollision関数で弾が敵に衝突しているかどうかの判定を行っています。衝突したら1を返し，それ以外は0を返します．衝突したら，敵が被弾した情報を格納する配列target_hit[j]に1を代入しています．被弾したら1を代入します．<br />
89行目は弾を描画し，91行目で敵を表示しています．<br />
<!--more--><br />
24行目からのキー入力処理をするcommand関数では，スペースキー(32)が押されると，弾を設定し，弾数を１増加させています．</p>
<p>48行目のdrawTarget関数では敵を描画しています．51行目で，敵が被弾していたら，continueを使い，被弾した敵の描画を飛ばします．</p>
<p>&nbsp;</p>
<p>説明はこのぐらいにして，ソースコードを読んで演習をしましょう．約100行です．</p>
<pre class="brush:cpp;">#include "dm3.h"
#include 
#include 
#include 

#define TARGET_NUM 10   // 敵の数
#define BULLET_NUM 100  // 弾数

int bullet_no = 0;
int target_hit&#91;TARGET_NUM&#93; = {0}; // 弾が当たったら１に設定
double start_x =0.0, start_y = 0.5, start_z = 0.5; // 初期位置
double R&#91;12&#93; = {1,0,0,0, 0,1,0,0, 0,0,1,0}; // 回転行列が格納される配列, 位置(x,y,z)&#91;m&#93;
double target_pos&#91;TARGET_NUM&#93;&#91;3&#93; = {0.0, 0.0, 0.5};   // 位置(x,y,z)&#91;m&#93;
double robot_pos&#91;3&#93;  = {start_x, start_y, start_z}; // ロボットの位置
double bullet_pos&#91;BULLET_NUM&#93;&#91;3&#93;; // 弾の位置;
double sides&#91;3&#93; = {1.0, 0.5, 1.0}; // 直方体のサイズ(x, y, z)&#91;m&#93;

void setBullet(int no, double pos&#91;3&#93;) {
    bullet_pos&#91;no&#93;&#91;0&#93; = pos&#91;0&#93;;
    bullet_pos&#91;no&#93;&#91;1&#93; = pos&#91;1&#93;;
    bullet_pos&#91;no&#93;&#91;2&#93; = pos&#91;2&#93;;
}

void command(int cmd) {
    switch (cmd) {
    case 'a':
        robot_pos&#91;0&#93; -= 1.0;
        break;
    case 'd':
        robot_pos&#91;0&#93; += 1.0;
        break;
    case 'x':
        robot_pos&#91;1&#93; -= 1.0;
        break;
    case 'w':
        robot_pos&#91;1&#93; += 1.0;
        break;
    case 32:
        setBullet(bullet_no,robot_pos);
        bullet_no++;
        printf("bullet=%d\n",bullet_no);
        break;
    default:
        printf("Input %c (%d)\n",(char)cmd, cmd);
    }
}

void drawTarget() {
    int i;
    for (i = 0; i &#60; TARGET_NUM; i++) {
        if (target_hit&#91;i&#93;) continue;
        dsSetColor(1.0, 0.0, 0.0); // 色の設定
        target_pos&#91;i&#93;&#91;0&#93; = 2 * i  + start_x - TARGET_NUM + 1;  // 位置のx成分
        target_pos&#91;i&#93;&#91;1&#93; = start_y + 10;       // 位置のx成分
        target_pos&#91;i&#93;&#91;2&#93; = 0.5;                 // 位置のz成分
        dsDrawBox(target_pos&#91;i&#93;,R,sides); // 直方体の表示
    }
}

void drawBullet(double pos&#91;3&#93;) {
    int i;
    dsSetColor(0.0, 0.0, 1.0); // 色の設定
    dsDrawSphere(pos,R,0.1); // 球の表示
}

// ブロックが他のブロックと衝突したら１を返す，それ以外は０を返す
int collision(double pos1&#91;3&#93;, double pos2&#91;3&#93;) {
    //　ブロック間の距離が１未満なら１を返すコードを
    //  ここに書きなさい
    double dist = sqrt((pos1&#91;0&#93;-pos2&#91;0&#93;) * (pos1&#91;0&#93;-pos2&#91;0&#93;)
                       + (pos1&#91;1&#93;-pos2&#91;1&#93;) * (pos1&#91;1&#93;-pos2&#91;1&#93;));
    if (dist &#60; 0.5) return 1;
    else            return 0;
}

void simLoop(int pause) {      /***  シミュレーションループ　***/
    int i,j;
    // ロボットの表示
    dsSetColor(1.0, 1.0, 0.0);   // 黄色
    dsDrawSphere(robot_pos, R, 0.5);

    for (i=0; i &#60; bullet_no; i++) {
        bullet_pos&#91;i&#93;&#91;1&#93; += 0.01;
        for (j = 0; j &#60; TARGET_NUM; j++) {
            if (collision(bullet_pos&#91;i&#93;,target_pos&#91;j&#93;)) {
                target_hit&#91;j&#93; = 1;
            }
        }
        drawBullet(bullet_pos&#91;i&#93;);  // 弾の描画
    }
    drawTarget();  // 敵の描画
}

int main() {       /*** main関数 ***/
    robot_pos&#91;1&#93; = start_y - 10;
    dmLoop(800, 600); // シミュレーションループ ウインドウの幅，高
    return 0;
}
</pre>
<p>では，演習をしながらシューティングゲームを作っていきましょう．</p>
<p>演習</p>
<ol>
<li><a href="http://demura.net/wordpress/wp-content/uploads/2015/07/step3-150701.zip">step3-150701.zip</a>をダウンロードし，実行してください．</li>
<li>ンプルでは弾が１発当たると敵は破壊されましたが，１発命中すると敵の色が赤くように改良しよう！</li>
<li>サンプルでは弾が１発当たると敵は破壊されましたが，１発命中すると敵の色が赤くなり，２発目で破壊するように改良しよう！</li>
<li>敵がインベーダーゲームのように移動するように改良しよう！</li>
<li>敵も弾を発射するように改良しよう！</li>
<li>敵の弾が自分のロボットに命中したら，ゲームオーバーにするよう改良しよう！また，敵を１台破壊したら１０点入るようにし，Scoreを表示しよう．</li>
</ol>
