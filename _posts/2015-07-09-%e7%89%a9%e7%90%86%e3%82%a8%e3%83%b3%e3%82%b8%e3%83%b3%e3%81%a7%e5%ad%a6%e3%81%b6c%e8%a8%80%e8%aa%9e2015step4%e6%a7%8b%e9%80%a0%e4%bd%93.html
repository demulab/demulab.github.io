---
layout: post
title: 物理エンジンで学ぶC言語2015[STEP4:構造体]
date: 2015-07-09 08:11:27.000000000 +09:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- ode
tags: []
meta:
  _edit_last: '2'
  views: '802'
author:
  login: demu
  email: info@demura.net
  display_name: demu
  first_name: ''
  last_name: ''
permalink: "/robot/9ode/11969.html"
---
<p><a href="http://demura.net/wordpress/wp-content/uploads/2015/07/step4.jpg"><img src="{{ site.baseurl }}/assets/images/2015/07/step4.jpg" alt="step4" width="816" height="659" class="aligncenter size-full wp-image-11976" /></a></p>
<p>シューティングゲームの４回目です．今回は前回までの演習を構造体を使い実装しています.</p>
<p>まず，12行目から20行目で構造体myObjectを定義しています．メンバとしては，位置pos[3]，回転行列R[12]，質量m，半径r，サイズside[3]，色*colorなどの変数です．</p>
<p>Step3との大きな違いは113行目のinitObject関数でゲームに使う物体を初期化しています．114行目のwelcomeMessage()で，ゲームのウェルカム表示と遊び方を表示します．具体的な遊び方は書いていないので，自分のオリジナルゲームを制作するときは、ユーザーが遊べるように遊び方を書きましょう．</p>
<p>また，Collision関数の引数がStep3では要素数３個の配列からmyObjecgt構造体に変更されています．</p>
<p>それ以外は，Step3とあまり違いはありません．Step3の演習は難しかったので，今回もほとんど同じにしています．構造体の復習を兼ねて，ソースコードを読んで演習をしましょう．</p>
<p><!--more--><br />
該当するソースコードは次のとおりです．</p>
<pre class="brush:cpp;">/* step4　*/
/* A simple shooting game */
/* step4 　2015-07-09 　    */
#include "dm4.h"
#include &#60;time.h&#62;
#include &#60;math.h&#62;
#include &#60;stdlib.h&#62;

#define TARGET_NUM 10   // 敵の数
#define BULLET_NUM 100  // 弾数

typedef struct myObject {
    double pos&#91;3&#93;; // 位置 x, y, z　&#91;m&#93;
    double R&#91;12&#93;;   // 回転行列 要素数4x3
    double m; // 質量 &#91;kg&#93;
    double r,l; // 半径 &#91;m&#93;, 長さ &#91;m&#93;
    double side&#91;3&#93;; // サイズ　x,y,z
    float *color; // 色 r,g,b
    int    hit; // 弾が当たった数
};

myObject target&#91;TARGET_NUM&#93;;
myObject bullet&#91;BULLET_NUM&#93;;
myObject robot;

int bullet_no = 0;
double start_x =0.0, start_y = 0.5, start_z = 0.5; // 初期位置
double R&#91;12&#93; = {1,0,0,0, 0,1,0,0, 0,0,1,0}; // 回転行列が格納される配列, 位置(x,y,z)&#91;m&#93;
double sides&#91;3&#93; = {1.0, 0.5, 1.0}; // 直方体のサイズ(x, y, z)&#91;m&#93;
static float blue&#91;3&#93; = {0.0, 0.0, 1.0}, red&#91;3&#93; = {1.0, 0, 0}, yellow&#91;3&#93; = {1.0, 1.0, 0}; // 青、赤、黄色

void setBullet(int no, double pos&#91;3&#93;) {
    bullet&#91;no&#93;.pos&#91;0&#93; = pos&#91;0&#93;;
    bullet&#91;no&#93;.pos&#91;1&#93; = pos&#91;1&#93;;
    bullet&#91;no&#93;.pos&#91;2&#93; = pos&#91;2&#93;;
}

void command(int cmd) {
    switch (cmd) {
    case 'a':
        robot.pos&#91;0&#93; -= 1.0;
        break;
    case 'd':
        robot.pos&#91;0&#93; += 1.0;
        break;
    case 'x':
        robot.pos&#91;1&#93; -= 1.0;
        break;
    case 'w':
        robot.pos&#91;1&#93; += 1.0;
        break;
    case 32:
        setBullet(bullet_no,robot.pos);
        bullet_no++;
        printf("bullet=%d\n",bullet_no);
        break;
    default:
        printf("Input %c (%d)\n",(char)cmd, cmd);
    }
}

void drawTarget() {
    int i;
    for (i = 0; i &#60; TARGET_NUM; i++) {
        if (target&#91;i&#93;.hit) continue;
        dsSetColor(target&#91;i&#93;.color&#91;0&#93;,target&#91;i&#93;.color&#91;1&#93;,target&#91;i&#93;.color&#91;2&#93;); // 色の設定
        dsDrawBox(target&#91;i&#93;.pos,target&#91;i&#93;.R,target&#91;i&#93;.side); // 直方体の表示
    }
}

void drawBullet() {
    int i;
    for (i=0; i&#60; BULLET_NUM; i++) {
        dsSetColor(bullet&#91;i&#93;.color&#91;0&#93;, bullet&#91;i&#93;.color&#91;1&#93;, bullet&#91;i&#93;.color&#91;2&#93;); // 色の設定
        dsDrawSphere(bullet&#91;i&#93;.pos,bullet&#91;i&#93;.R, bullet&#91;i&#93;.r); // 球の表示
    }
}

void drawRobot() {
    // ロボットの表示
    dsSetColor(robot.color&#91;0&#93;, robot.color&#91;1&#93;, robot.color&#91;2&#93;);   // 黄色
    dsDrawSphere(robot.pos, robot.R, robot.r);
}

// ブロックが他のブロックと衝突したら１を返す，それ以外は０を返す
int collision(myObject a, myObject b) {
    //　ブロック間の距離が１未満なら１を返すコードを
    //  ここに書きなさい
    double dist = sqrt((a.pos&#91;0&#93;- b.pos&#91;0&#93;) * (a.pos&#91;0&#93;-b.pos&#91;0&#93;)
                       + (a.pos&#91;1&#93;-b.pos&#91;1&#93;) * (a.pos&#91;1&#93;-b.pos&#91;1&#93;));
    if (dist &#60; 0.5) return 1;
    else            return 0;
}

void simLoop(int pause) {      /***  シミュレーションループ　***/
    int i,j;


    for (i=0; i &#60; bullet_no; i++) {
        bullet&#91;i&#93;.pos&#91;1&#93; += 0.01;
        for (j = 0; j &#60; TARGET_NUM; j++) {
            if (collision(bullet&#91;i&#93;,target&#91;j&#93;)) {
                target&#91;j&#93;.hit = 1;
            }
        }
    }
    drawBullet();
    drawTarget();  // 敵の描画
    drawRobot();   // ロボットの描画
}

// 物体の初期化
void initObject() {
    int i, j, k, c;

    // 敵
    for (i =0; i &#60; TARGET_NUM; i++) {
        target&#91;i&#93;.pos&#91;0&#93; = 2 * i  + start_x - TARGET_NUM + 1;  // 位置のx成分
        target&#91;i&#93;.pos&#91;1&#93; = start_y + 10;       // 位置のx成分
        target&#91;i&#93;.pos&#91;2&#93; = 0.5;
        target&#91;i&#93;.color = blue;
        target&#91;i&#93;.hit   = 0;
        for (k = 0; k &#60; 12; k++) target&#91;i&#93;.R&#91;k&#93; = R&#91;k&#93;;
        for (j = 0; j &#60; 3; j++)  target&#91;i&#93;.side&#91;j&#93; = sides&#91;j&#93;;
    }

    // ロボット
    robot.pos&#91;0&#93; = start_x;
    robot.pos&#91;1&#93; = start_y - 10;
    robot.pos&#91;2&#93; = start_z;
    robot.color  = yellow;
    for (k = 0; k &#60; 12; k++) robot.R&#91;k&#93; = R&#91;k&#93;;
    robot.r      = 0.5;

    // 弾
    for (i =0; i &#60; BULLET_NUM; i++) {
        for (j=0; j &#60; 3; j++) bullet&#91;i&#93;.pos&#91;j&#93; = robot.pos&#91;j&#93;;
        bullet&#91;i&#93;.color = red;
        for (k = 0; k &#60; 12; k++) bullet&#91;i&#93;.R&#91;k&#93; = R&#91;k&#93;;
        bullet&#91;i&#93;.r = 0.1;
    }
}

void welcomeMessage() {
    printf("****************************************\n");
    printf("* Welcom to the Simple Shooting Game ! *\n");
    printf("****************************************\n\n");
    printf(" Please write here. how to play.\n");
}

int main() {       /*** main関数 ***/
    welcomeMessage();
    initObject(); // 物体の初期化
    dmLoop(800, 600); // シミュレーションループ ウインドウの幅，高
    return 0;
}
</pre>
<p>演習</p>
<ol>
<li><a href="http://demura.net/wordpress/wp-content/uploads/2015/07/step4-150709.zip">step4-150709.zip</a>をダウンロードし，実行してください．</li>
<li>遊び方を表示するwelcomeMessage()を自分の好きなように変えよう！</li>
<li>サンプルでは弾が１発当たると敵は破壊されましたが，１発命中すると敵の色が赤くように改良しよう！</li>
<li>サンプルでは弾が１発当たると敵は破壊されましたが，１発命中すると敵の色が赤くなり，２発目で破壊するように改良しよう！</li>
<li>敵がインベーダーゲームのように移動するように改良しよう！</li>
<li>敵も弾を発射するように改良しよう！</li>
<li>敵の弾が自分のロボットに命中したら，ゲームオーバーにするよう改良しよう！また，敵を１台破壊したら１０点入るようにし，Scoreを表示しよう．</li>
<li>ロボットの初期位置に弾が残って表示されるバグがあります。バグを取ろう！</li>
</ol>
