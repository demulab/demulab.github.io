---
layout: post
title: 物理エンジンODEで学ぶC言語 [STEP5：まとめ]
date: 2016-07-13 06:53:24.000000000 +09:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- lecture
tags: []
meta:
  _edit_last: '2'
  views: '418'
  _thumbnail_id: '12980'
author:
  login: demu
  email: info@demura.net
  display_name: demu
  first_name: ''
  last_name: ''
permalink: "/education/lecture/12971.html"
---
<p>[caption id="attachment_9384" align="alignnone" width="400"]<a href="http://demura.net/wordpress/wp-content/uploads/2012/01/block2.jpg"><img src="{{ site.baseurl }}/assets/images/2016/07/block2.jpg" alt="" title="block2" width="400" height="313" class="size-full wp-image-9384" /></a> ブロック崩し風ゲーム。未完成。続きを作ろう！[/caption]</p>
<p>今回でこの講座は終わりです。先週作り始めたブロック崩し風ゲームを完成させましょう。</p>
<p>この手のゲームで必要になることは、ボールがブロックの当たったときにブロックの消す処理です。このサンプルプログラムではブロックを３個用意し、それぞれの当たりを判定する変数をblock1_hit, block2_hit, block3_hitとして０で初期化します。</p>
<p>ボールとブロックが衝突したらその変数を１に設定し、そのブロックを破壊し表示しないという処理を行っています。</p>
<pre class="brush:cpp;">// step5.cpp
int block1_hit = 0, block2_hit = 0, block3_hit = 0; //　ブロックにボールが衝突すれば１、しないと０

/***  シミュレーションループ　***/
void simLoop(int pause)
{
    int i, j;

    dmWorldQuickStep(); // シミュレーションを１ステップ進める(高速版)

    dmDraw(&amp;ball);
    dmDraw(&amp;bar);
    dmDraw(&amp;field);

    for (i =0; i &#60; 3; i++)
    {
        dmDraw(&amp;fence&#91;i&#93;);
    }

    // ブロックがボールに衝突していない場合はブロックを表示し
    // ブロックがボールに衝突した場合はブロックを破壊する。
    if (block1_hit==0) dmDraw(&amp;block1);
    else                  dmDestroyBox0(&amp;block1);

    if (block2_hit==0) dmDraw(&amp;block2);
    else                  dmDestroyBox0(&amp;block2);

    if (block3_hit==0) dmDraw(&amp;block3);
    else                  dmDestroyBox0(&amp;block3);

    STEPS++;
}</pre>
<p>次に、今まで秘密のベールに包まれていたdm6.cppを説明します。このファイルでODEを簡単に使う関数を作っています。まず、２，３行目のexternで始まる変数の宣言は、dm6.cpp以外のファイルで宣言しているよとコンパイラーに教えています。これらの行がないとblock1, block1_hitが宣言されていないとエラーになり、externを付けないとstep6.cppでも宣言されているので２重定義でエラーになってしまいます。大きなプログラムは複数のファイルで構成されるのでこのexternは覚えておきましょう。</p>
<p>お次は、衝突検出を説明します。これはdm6.cpp内のnearCallback関数で行われています。if else文でブロック１のジオメトリ(block1.geom)、ブロック２のジオメトリ(block2.geom)、ブロック３のジオメトリ(block3.geom)がボールのジオメトリ(ball.geom)がo1, o2のどちらかなら衝突しているので、衝突判定用の変数block1_hit, block2_hit, block3_hitに１を代入しています。なお、ジオメトリとはODEで衝突判定に使われる物体の属性です。</p>
<p>また、nearCallback関数は２つの物体（正確にはジオメトリ）が接近して衝突しそうになったら自動で呼び出せれる関数です。このような関数をコールバック関数と呼びます。電話のコールバックをイメージしてください。引数のジオメトリo1, o2は衝突しそうな２つのジオメトリです。</p>
<p>このサンプルプログラムでたった３個のブロック崩し風ゲームは完成です。後は、いろいろ工夫して自分だけのゲームを完成させてください。</p>
<p>終わり。</p>
<pre class="brush:cpp;">// dm5.cpp
extern dmObject ball, field, fence&#91;3&#93;, bar, block1, block2, block3;
extern int block1_hit, block2_hit, block3_hit;

/*** 衝突検出関数（コールバック関数） ***/
void nearCallback(void *data, dGeomID o1, dGeomID o2)
{
    static const int N = 10; // 接触点数の最大値
    dContact contact&#91;N&#93;;     // 接触点

    // 衝突情報の生成 nは衝突点数
    int n = dCollide(o1,o2,N,&amp;contact&#91;0&#93;.geom,sizeof(dContact));

    for (int i = 0; i &#60; n; i++)
    {
        contact&#91;i&#93;.surface.mode = dContactBounce; // 接触面の反発性を設定

        //　ボールとバーが接触したら反発係数を1.5に設定
        if(((ball.geom == o1) &amp;&amp; (bar.geom == o2)) || ((ball.geom == o2) &amp;&amp; (bar.geom == o1)))
        {
            contact&#91;i&#93;.surface.bounce = 1.5;          // 反発係数(実際の世界では0.0から1.0)
        }
        // ボールと床が接触したら反発係数を0.5に設定
        else if (((ball.geom == o1) &amp;&amp; (field.geom == o2)) || ((ball.geom == o2) &amp;&amp; (field.geom == o1)))
        {
            contact&#91;i&#93;.surface.bounce = 0.5;
        }
        // ボールとブロック１が接触したら。block1_hitを１に設定
        else if (((ball.geom == o1) &amp;&amp; (block1.geom == o2)) || ((ball.geom == o2) &amp;&amp; (block1.geom == o1)))
        {
             block1_hit = 1;
        }
        // ボールとブロック2が接触したら。block2_hitを１に設定
        else if (((ball.geom == o1) &amp;&amp; (block2.geom == o2)) || ((ball.geom == o2) &amp;&amp; (block2.geom == o1)))
        {
             block2_hit = 1;
        }
         // ボールとブロック3が接触したら。block2_hitを１に設定
        else if (((ball.geom == o1) &amp;&amp; (block3.geom == o2)) || ((ball.geom == o2) &amp;&amp; (block3.geom == o1)))
        {
             block3_hit = 1;
        }
        // その他は反発係数を0.8に設定
        else
        {
            contact&#91;i&#93;.surface.bounce = 0.8;
        }

        // contact&#91;i&#93;.surface.bounce_vel = 0.05;      // 反発に必要な最低速度
        contact&#91;i&#93;.surface.mu = 0.0;// dInfinity;        // 摩擦係数

        // 接触ジョイントの生成
        dJointID c = dJointCreateContact(world,contactgroup,
                                         &amp;contact&#91;i&#93;);
        // 接触している２つの剛体を接触ジョイントにより拘束
        dJointAttach(c,dGeomGetBody(contact&#91;i&#93;.geom.g1),
                     dGeomGetBody(contact&#91;i&#93;.geom.g2));
    }
}</pre>
<p>ホームワーク</p>
<ol>
<li><a href="http://demura.net/lecture/12971.html/attachment/step5-160713" rel="attachment wp-att-12972">step5-160713.zipをダウンロードして実行しよう！</a></li>
<li>ブロックの数を１個増やそう。</li>
<li>３で作ったブロックの色を黒に変更しよう。</li>
<li>ブロックの数を増やし、競技盤の半分ぐらいは埋め尽くそう。配列を使うのが望ましい。</li>
<li>ボールの初期位置と飛び出す方向をランダムに変えよう。</li>
<li>バーが競技盤を飛び出してしまいます。飛び出さないようにしよう。</li>
<li>得点を表示する機能を付けよう。標準出力にprintfでもかまいません。</li>
<li>いろいろ工夫して自分だけのブロック崩し風ゲームを作ろう！遊ぶためにゲームの説明を文字ウインドウに表示しよう。</li>
</ol>
