---
layout: post
title: RobotVision勉強会：第４回 マウスイベント処理
date: 2017-11-09 20:57:19.000000000 +09:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- robocup
tags: []
meta:
  _edit_last: '2'
  views: '434'
  _oembed_26edc2a2c53d7912a1fe977f4592ef1b: "{{unknown}}"
author:
  login: demu
  email: info@demura.net
  display_name: demu
  first_name: ''
  last_name: ''
permalink: "/robot/robocup/13915.html"
---
<p>&nbsp;</p>
<p><a href="http://demura.net/robocup/13915.html/attachment/color_box" rel="attachment wp-att-13917"><img src="{{ site.baseurl }}/assets/images/2017/11/color_box.png" alt="" width="642" height="557" class="aligncenter size-full wp-image-13917" /></a></p>
<p>この記事は私が主催しているRobotVision勉強会の内容メモです。OpenCVの内容については下のサイトやOpenCV3.2.0のドキュメントを参考にしています。なお、開発環境はUbuntu16.04、OpenCV3.2.0です。第４回はマウスのイベント処理です。以下のサンプルプログラムではマウスで画像中の矩形領域を設定し、そこに含まれている画素の赤、緑、青成分の最小、最大値を取得します。<br />
なお、マウスでボックスを描画し、その座標を取得することに関しては、Learning OpenCV 3 (著者: Adrian Kaehler、Gary Bradski, 出版社：O'REILLY)のExample9-2 P214,215のコードをもとに作成しました。Learning OpenCV 3は990ページもある大型本で前著より約400ページも増量されとても参考になります。お勧めです。ペーパーバックス版を購入したましたが、これだけ分厚と持ち運びが不便なのでKindle版が良いかもしれませんね。<br />
<a href="https://www.amazon.co.jp/gp/product/1491937998/ref=as_li_tl?ie=UTF8&amp;camp=247&amp;creative=1211&amp;creativeASIN=1491937998&amp;linkCode=as2&amp;tag=demuranet-22&amp;linkId=04fff20aa7853c53d1beeb24690efb02" target="_blank" rel="noopener"><img src="{{ site.baseurl }}/assets/images/2017/11/q?_encoding=UTF8&amp;MarketPlace=JP&amp;ASIN=1491937998&amp;ServiceVersion=20070822&amp;ID=AsinImage&amp;WS=1&amp;Format=_SL250_&amp;tag=demuranet-22" border="0" /></a><img src="{{ site.baseurl }}/assets/images/2017/11/ir?t=demuranet-22&amp;l=am2&amp;o=9&amp;a=1491937998" border="0" alt="" width="1" height="1" style="border: none !important; margin: 0px !important;" /></p>
<p><strong>1．サンプルコード</strong></p>
<pre class="brush:cpp;">// Robot Vision勉強会 sample4.cpp
// 2017-11-09
// 
// マウスでドラッグしたボックス領域に含まれる画素の
// 赤、緑、青成分の最小、最大値を取得するプログラム。

#include &#60;opencv2/imgproc.hpp&#62;
#include &#60;opencv2/highgui.hpp&#62;
#include &#60;opencv2/core/core.hpp&#62;
#include &#60;iostream&#62;

cv::Rect box;

bool drawing_box = false; 

// ボックスの始点、終点座標 
int start_x = 0, start_y = 0, end_x = 0, end_y =0;

// ボックスの描画
void drawBox(cv::Mat* img, cv::Rect box){
  cv::rectangle(*img, box.tl(), box.br(),cv::Scalar(0, 0, 255));
}

// コールバック関数
void myMouseCallback(int event, int x, int y, int flags, void* param){
  cv::Mat* image = static_cast&#60;cv::Mat*&#62;(param);

  switch (event){
  case cv::EVENT_MOUSEMOVE:
    if (drawing_box){
      box.width =  x - box.x;
      box.height = y - box.y;
    }
    break;
  case cv::EVENT_LBUTTONDOWN:
    drawing_box = true;
    start_x = x;
    start_y = y;
    box = cv::Rect(x, y, 0, 0);
    break;
  case cv::EVENT_LBUTTONUP:
    drawing_box = false;
    if (box.width &#60; 0){
      box.x += box.width;
      box.width *= -1;
    }
    if (box.height &#60; 0){
      box.y += box.height;
      box.height *= -1;
    } 
    end_x = x;
    end_y = y;
    drawBox(image, box);
    break;
  }
}

int main(void)
{
  cv::Mat src;

  // trueになると閾値内のピクセルだけを赤色に変更
  bool paint_flag = false;  
  // trueになると閾値内のピクセルを赤色、その他のピクセルを白に変更
  bool color_flag = false;
  
  std::string WINDOW_NAME = "Extract color";
  box = cv::Rect(-1, -1, 0, 0);

  // 画像のロード
  src = cv::imread("winkit2.jpg", cv::IMREAD_COLOR);
  if(src.empty()) {
    std::cerr &#60;&#60; "Failed to open image file." &#60;&#60; std::endl;
    return -1;
  }

  int height = src.rows;       // 画像の高さ&#91;pixel&#93;
  int width  = src.cols;       // 画像の幅&#91;pixel&#93;
  int step   = src.step;       // 1行のチャンネル総数
  int c      = src.channels(); // チャンネル数   

  
  cv::Mat tmp = src.clone();

  // ウィンドウの生成
  cv::namedWindow(WINDOW_NAME, CV_WINDOW_AUTOSIZE);

  // コールバック関数の設定
  cv::setMouseCallback(WINDOW_NAME, myMouseCallback, (void *)&amp;src);

  while (true){
    src.copyTo(tmp);

    // マウスの左クリックを離すまでボックスを一時的に描画
    if (drawing_box) {
      drawBox(&amp;tmp, box);
    }

    cv::imshow(WINDOW_NAME, tmp);

    int blue_min  = 999, blue_max  = -999;
    int green_min = 999, green_max = -999;
    int red_min   = 999, red_max   = -999;

    // ボックス領域の各色成分の最小、最大値を取得
    for (int y =start_y; y &#60; end_y; y++) {
      for (int x = start_x; x &#60; end_x; x++) { int b = src.data&#91;y* step + x * c + 0&#93;; if (blue_min &#62; b) blue_min = b;
	if (blue_max &#60; b) blue_max = b; int g = src.data&#91;y* step + x * c + 1&#93;; if (green_min &#62; g) green_min = g;
	if (green_max &#60; g) green_max = g; int r = src.data&#91;y* step + x * c + 2&#93;; if (red_min &#62; r) red_min = r;
	if (red_max &#60; r) red_max = r;
      }
    }

    std::cout &#60;&#60; "blue : min=" &#60;&#60; blue_min  &#60;&#60; " max=" &#60;&#60; blue_max  &#60;&#60; std::endl;
    std::cout &#60;&#60; "green: min=" &#60;&#60; green_min &#60;&#60; " max=" &#60;&#60; green_max &#60;&#60; std::endl;
    std::cout &#60;&#60; "red  : min=" &#60;&#60; red_min   &#60;&#60; " max=" &#60;&#60; red_max   &#60;&#60; std::endl;

    //　取得した閾値の範囲に入る画素を赤く塗る
    for (int y =0; y &#60; height; y++) {
      for (int x = 0; x &#60; width; x++) {
	int b = tmp.data&#91;y* step + x * c + 0&#93;;
	int g = tmp.data&#91;y* step + x * c + 1&#93;;
	int r = tmp.data&#91;y* step + x * c + 2&#93;;
	if (blue_min &#60;= b &amp;&amp; b &#60;= blue_max &amp;&amp; green_min &#60;= g &amp;&amp; g &#60;= green_max
	    &amp;&amp; red_min &#60;= r &amp;&amp; r &#60;= red_max) {
	  if (paint_flag == true) {
	    src.data&#91;y* step + x * c + 0&#93; = 0;
	    src.data&#91;y* step + x * c + 1&#93; = 0;
	    src.data&#91;y* step + x * c + 2&#93; = 255;
	  }
	}
	else {
	  if (color_flag == true) {
	    src.data&#91;y* step + x * c + 0&#93; = 255;
	    src.data&#91;y* step + x * c + 1&#93; = 255;
	    src.data&#91;y* step + x * c + 2&#93; = 255;
	  }
	}
      }
    }
      
    
    int c = cv::waitKey(1);
    switch (c)  {
    case 'p':
      paint_flag = true;
      break;
    case 'c':
      color_flag = true;
      break;
    case 32: // space 
       paint_flag = color_flag = false;
       start_x = start_y = end_x = end_y = 0;
       box.x = box.y = box.width = box.height = 0;
       src = cv::imread("winkit2.jpg", cv::IMREAD_COLOR);
       break;
    }
  }
  return 0;
}
</pre>
<p>２．ハンズオン</p>
<ul>
<li>このソースコード<a href="http://demura.net/robocup/13915.html/attachment/sample4" rel="attachment wp-att-13916">sample4</a>をダウンロードして次のコマンドで解凍、コンパイルして実行しよう。マウスでドラッグすると領域が選択され、そこに含まれているピクセルの最小、最大値が閾値になります。キーボードからpを入力すると、閾値の範囲になるピクセルが赤く塗られます。cを入力すると赤く塗られたピクセル以外が白くなり、画像中のどの領域がその閾値の範囲にあるかよくわかります。広い領域を選択すると画像中のいろいろなピクセルがその閾値内に入るので、どの領域を選択するかが重要です。
<ul>
<li>$  tar xvzf sample4.tgz</li>
<li>$  cd sample4</li>
<li>$  cmake .</li>
<li>$ make</li>
<li>./sample4</li>
</ul>
</li>
<li>ソースコードのAPIの意味を調べてプログラムを理解しよう。</li>
<li>このサンプルプログラムでは選択した領域の各画素の最小・最大値を閾値としているので、領域がうまく分割されません。第２回の閾値をスライドバーで変化させるプログラムとこのサンプルを組み合わせて使い勝手をよくしよう！</li>
<li>このサンプルはRGB表色系を使っていますが、明るさの変化に弱いです。これをYUV表色系に変更することでロバストにしよう！</li>
</ul>
