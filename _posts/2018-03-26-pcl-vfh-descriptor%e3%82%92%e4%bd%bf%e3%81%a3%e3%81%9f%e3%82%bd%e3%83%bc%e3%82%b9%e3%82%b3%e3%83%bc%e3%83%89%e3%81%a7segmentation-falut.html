---
layout: post
title: 'PCL:  VFH Descriptorを使ったソースコードでsegmentation fault'
date: 2018-03-26 16:52:54.000000000 +09:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- misc
tags: []
meta:
  _edit_last: '2'
  views: '252'
author:
  login: demu
  email: info@demura.net
  display_name: demu
  first_name: ''
  last_name: ''
permalink: "/misc/14363.html"
---
<p>VHF (Viewpoint Feature Histogram) descriptorsを使った<a href="https://github.com/ros-industrial/swri-ros-pkg/blob/master/freetail/vfh_recognition/src/vfh_recognition_node.cpp">vfh_recognition_node.cpp</a>でsegmentation faultのエラーを解決するために数日悩んだのでメモを残す。<br />
 次のソースコード42行目のvfh.compute (*vfhs)でexit-11、セグメンテーションフォールトでプロセスが落ちる。バックトレースするとeigen3ライブラリが怪しい。結局、いろいろ試したり、調べた結果、PCL Users mailing listの<a href="http://www.pcl-users.org/Point-Histogram-Descriptors-Segmentation-fault-core-dumped-td4043794.html">過去記事に答え</a>があった。pclをC++11のフラグをつけてソースからビルドし直すと解決した。</p>
<pre class="brush:cpp;">bool recognize_cb(tabletop_object_detector::TabletopObjectRecognition::Request &amp;srv_request,
		  tabletop_object_detector::TabletopObjectRecognition::Response &amp;srv_response)
{
  
  //build kdtree index
  flann::Index&#60;flann::ChiSquareDistance&#60;float&#62; &#62; index (*data, flann::LinearIndexParams ());
   index.buildIndex ();
   
  //clear any models in the response:
  srv_response.models.resize(0);
  
  // Create the VFH estimation class, and pass the input dataset+normals to it
  pcl::VFHEstimation&#60;pcl::PointXYZ, pcl::Normal, pcl::VFHSignature308&#62; vfh;
  std::vector&#60;pcl::PointCloud&#60;pcl::PointXYZ&#62;::Ptr&#62; clouds;
  
  //Euclidean segmentation:
  SegmentCloud(fromKinect, clouds);
 
  //For storing results:
  pcl::PointCloud&#60;pcl::PointXYZ&#62;::Ptr aligned_template (new pcl::PointCloud&#60;pcl::PointXYZ&#62;);
  sensor_msgs::PointCloud2 recognized_msg;
  Eigen::Matrix4f objectToView;
  int numFound = 0;
  std::cout &#60;&#60; "Found " &#60;&#60; clouds.size() &#60;&#60; " clusters.\n"; 
  //For each segment passed in:
  for(unsigned int segment_it = 0; segment_it &#60; clouds.size(); segment_it++){
    vfh.setInputCloud (clouds.at(segment_it));
    //Estimate normals:
    pcl::NormalEstimation&#60;pcl::PointXYZ, pcl::Normal&#62; ne;
    ne.setInputCloud (clouds.at(segment_it));
    pcl::search::KdTree&#60;pcl::PointXYZ&#62;::Ptr treeNorm (new pcl::search::KdTree&#60;pcl::PointXYZ&#62; ());
    ne.setSearchMethod (treeNorm);
    pcl::PointCloud&#60;pcl::Normal&#62;::Ptr cloud_normals (new pcl::PointCloud&#60;pcl::Normal&#62;);
    ne.setRadiusSearch (0.03);
    ne.compute (*cloud_normals);
    
    //VFH estimation
    vfh.setInputNormals (cloud_normals);
    pcl::search::KdTree&#60;pcl::PointXYZ&#62;::Ptr tree (new pcl::search::KdTree&#60;pcl::PointXYZ&#62; ());
    vfh.setSearchMethod (tree);
    pcl::PointCloud&#60;pcl::VFHSignature308&#62;::Ptr vfhs (new pcl::PointCloud&#60;pcl::VFHSignature308&#62; ());
    vfh.compute (*vfhs);

    //Load histogram  
    vfh_model histogram;
    histogram.second.resize(308);
    for (size_t i = 0; i &#60; 308; ++i)
      {
	histogram.second&#91;i&#93; = vfhs-&#62;points&#91;0&#93;.histogram&#91;i&#93;;
      }

    //Algorithm parameters  
    float thresh = 100; //similarity threshold
    int k = 1; //number of neighbors
    
    //KNN classification
    flann::Index&#60;flann::ChiSquareDistance&#60;float&#62; &#62; index (*data, flann::LinearIndexParams ());
    index.buildIndex ();
    nearestKSearch (index, histogram, k, k_indices, k_distances);

    //If model match is close enough, do finer pose estimation by RANSAC fitting.
    if(k_distances&#91;0&#93;&#91;0&#93; &#60; thresh){
      numFound++;
      //Load nearest match
      std::string cloud_name = models.at(k_indices&#91;0&#93;&#91;0&#93;).first;
      
      //Extract object label and view number from file name:
      cloud_name.erase(cloud_name.end()-8, cloud_name.end()-4);
      std::string recognitionLabel, viewNumber;
      recognitionLabel.assign(cloud_name.begin()+5, cloud_name.end()-6);
      viewNumber.assign(cloud_name.end()-5, cloud_name.end()-4);
    
      
      //ROS_INFO the recognitionLabel and view number. This info will later be used to look the object up in a manipulation database.
      ROS_INFO("%s", recognitionLabel.c_str());
      ROS_INFO("%i", atoi(viewNumber.c_str()));
      
      //Here, objectToView is the transformation of the detected object to its nearest viewpoint in the database.
      //To get the object pose in the world frame: T(camera_to_world)*T(training_view_to_camera)*objectToView. 
      //The transformation to camera coordinates would then happen here by finding T(view_cam) in a lookup table and premultiplying
      //by objectToView
      alignTemplate(clouds.at(segment_it), cloud_name, aligned_template, objectToView);
      //Convert rotational component of objectToView to Quaternion for messaging:
      Eigen::Matrix3f rotation = objectToView.block&#60;3,3&#62;(0, 0);
      Eigen::Quaternionf rotQ(rotation);
     
      //Set num models in request:
      srv_request.num_models = numFound;
      //Build service response:
      srv_response.models.resize(numFound);
      srv_response.models&#91;numFound-1&#93;.model_list.resize(1);
      //model_id
      srv_response.models&#91;numFound-1&#93;.model_list&#91;0&#93;.model_id = atoi(viewNumber.c_str()); //This ID will eventually correspond to the object label.
      //PoseStamped
        //Header
      srv_response.models&#91;numFound-1&#93;.model_list&#91;0&#93;.pose.header.seq = 1; //Don't know what this is, but it's set.
      srv_response.models&#91;numFound-1&#93;.model_list&#91;0&#93;.pose.header.stamp = fromKinect.header.stamp;
      srv_response.models&#91;numFound-1&#93;.model_list&#91;0&#93;.pose.header.frame_id = "/camera_depth_optical_frame";
        //Pose
          //Position:
      srv_response.models&#91;numFound-1&#93;.model_list&#91;0&#93;.pose.pose.position.x = objectToView(0,3);
      srv_response.models&#91;numFound-1&#93;.model_list&#91;0&#93;.pose.pose.position.y = objectToView(1,3);
      srv_response.models&#91;numFound-1&#93;.model_list&#91;0&#93;.pose.pose.position.z = objectToView(2,3);
          //Orientation:
      srv_response.models&#91;numFound-1&#93;.model_list&#91;0&#93;.pose.pose.orientation.x = rotQ.x();
      srv_response.models&#91;numFound-1&#93;.model_list&#91;0&#93;.pose.pose.orientation.y = rotQ.y();
      srv_response.models&#91;numFound-1&#93;.model_list&#91;0&#93;.pose.pose.orientation.z = rotQ.z();
      srv_response.models&#91;numFound-1&#93;.model_list&#91;0&#93;.pose.pose.orientation.w = rotQ.w();
      //confidence and cluster_model_indcices are not currently used.
      
    }//end threshold if statement
    
  }//end segment iterator
  
  return(1);
}
</pre>
<p><strong>環 境</strong></p>
<ul>
<li>Ubuntu-16.04, PCL-1.8.1, gcc-5.4.0</li>
</ul>
<p><strong>実施した作業</strong></p>
<ul>
<li>ここでは、pclのソースコードが~/src/pcl/pcl-1.8.1にあるする。
<ul>
<li><code>cd ~/src/pcl/pcl-1.8.1</code></li>
</ul>
</li>
<li> PCLのCMakeLists.txtの一番最後に以下を追加。
<ul>
<li><code>set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11")</code></li>
</ul>
</li>
<li><code>cd ~/src/pcl/pcl-1.8.1</code></li>
<li><code>mkdir build</code></li>
<li><code>cd build</code></li>
<li><code>cmake -DCMAKE_BUILD_TYPE=Release ..</code></li>
<li><code>make -j12</code></li>
<li><code>sudo make install</code></li>
<li>エラーが出ていたソースコードをビルドし直す。以下は例。
<ul>
<li><code>cd ~/catkin_ws</code></li>
<li><code>catkin_make</code></li>
</ul>
</li>
</ul>
<p>終わり</p>
<p>&nbsp;</p>
