---
layout: post
title: ROS演習6-2018：デッドレコニングを実装しよう！
date: 2018-11-25 10:10:57.000000000 +09:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- lecture
tags: []
meta:
  _edit_last: '2'
  views: '1989'
  _thumbnail_id: '14624'
  _wp_old_date: '2018-11-20'
author:
  login: demu
  email: info@demura.net
  display_name: demu
  first_name: ''
  last_name: ''
permalink: "/education/lecture/15328.html"
---
<ul>
<li><span style="color: #ff0000;"><strong>.bashrcに以下を追加したらWSLのgazebo上でもturtulebot3が稀に動きますが安定していないので使えません。rvizを使ってください(2018-11-30)</strong></span>
<ul>
<li><span style="color: #ff0000;"><strong>export GAZEBO_MASTER_URI=http://localhost:11345</strong></span></li>
<li><span style="color: #ff0000;"><strong>export  ROS_IP=127.0.0.1</strong></span></li>
</ul>
</li>
<li><strong><span style="color: #ff0000;">WSLのUbuntu16.04でgazebo上のturtlebot3が動かないという問題が発生したのでrvizを使ってください(2018-11-22)。</span></strong></li>
</ul>
<p>この記事は私が金沢工業大学ロボティクス学科で担当している2018年度後学期開講の講義ロボットプログラミングⅡ用です。今回はTurtlebot3にデッドレコニングを実装します。</p>
<ul>
<li>デッドレコニング説明資料
<ul>
<li>以下の説明資料をダウンロードして読んでください。これをGazebo上のTurtlebot3に実装していきましょう。
<ul>
<li><a href="http://demura.net/wordpress/wp-content/uploads/2018/11/deadReckoning.pdf">deadReckoning.pdf</a></li>
</ul>
</li>
</ul>
</li>
<li>テンプレートファイル</li>
</ul>
<pre class="brush:cpp;">// ファイル名　my_odom3.cpp
#include &#60;ros/ros.h&#62;  // rosで必要はヘッダーファイル
#include &#60;geometry_msgs/Twist.h&#62; // ロボットを動かすために必要
#include &#60;nav_msgs/Odometry.h&#62;
#include &#60;tf/transform_broadcaster.h&#62;
#include &#60;tf/transform_datatypes.h&#62;
#include &#60;gazebo_msgs/ModelStates.h&#62; 
#include &#60;sensor_msgs/JointState.h&#62;
#include 

using namespace std;

// コールバック関数。並進、回転速度の表示。
void cbVel(const geometry_msgs::Twist::ConstPtr&amp; vel) {
  cout &#60;&#60; "Linear :" &#60;&#60; vel-&#62;linear.x &#60;&#60; endl;
  cout &#60;&#60; "Angular:" &#60;&#60; vel-&#62;angular.z &#60;&#60; endl; } // /odomトピックから位置posと姿勢poseを表示 void cbOdom(const nav_msgs::Odometry::ConstPtr&amp; msg) { ROS_INFO("Seq: %d", msg-&#62;header.seq);
  ROS_INFO("/odom Pos (x:%f, y:%f, z:%f)", msg-&#62;pose.pose.position.x,msg-&#62;pose.pose.position.y, msg-&#62;pose.pose.position.z);

  tf::Quaternion q(msg-&#62;pose.pose.orientation.x, msg-&#62;pose.pose.orientation.y, msg-&#62;pose.pose.orientation.z, msg-&#62;pose.pose.orientation.w);  
  // tf::Quaternion q(quat.x, quat.y, quat.z, quat.w);
  tf::Matrix3x3 m(q);
  double roll, pitch, yaw;
  m.getRPY(roll, pitch, yaw);

  ROS_INFO("/odom Pose (roll:%f, pitch:%f, yaw:%f) ", roll, pitch, yaw);
  ROS_INFO("Vel (Linear:%f, Angular:%f)", msg-&#62;twist.twist.linear.x,msg-&#62;twist.twist.angular.z);
												  
}

// /gazebo/model_statesトピックから真の位置Pos(x,y,z)と姿勢Pose(roll, pitch ,yaw)を表示
void cbModelStates(const gazebo_msgs::ModelStates::ConstPtr&amp; msg)
{
  ROS_INFO("Real Pos (x:%f, y:%f, z:%f)", msg-&#62;pose&#91;1&#93;.position.x,msg-&#62;pose&#91;1&#93;.position.y, msg-&#62;pose&#91;1&#93;.position.z);

  tf::Quaternion q(msg-&#62;pose&#91;1&#93;.orientation.x, msg-&#62;pose&#91;1&#93;.orientation.y, msg-&#62;pose&#91;1&#93;.orientation.z, msg-&#62;pose&#91;1&#93;.orientation.w);  
  // tf::Quaternion q(quat.x, quat.y, quat.z, quat.w);
  tf::Matrix3x3 m(q);
  double roll, pitch, yaw;
  m.getRPY(roll, pitch, yaw);

  ROS_INFO("Real Pose (roll:%f, pitch:%f, yaw:%f) ", roll, pitch, yaw);
												  
}

// cbMyOdom：この関数に自分のオドメトリを実装しよう！
// /joint_statesトピックから左右のjoint(車輪回転軸)の位置（回転角度)&#91;rad&#93;を表示
// 参考：Turtlebot3の車輪直径0.066 &#91;m&#93;
void cbMyOdom(const sensor_msgs::JointState::ConstPtr&amp; jointstate)
{
  double wheel_right_joint_pos = jointstate-&#62;position&#91;0&#93;; // 右車軸の位置&#91;rad&#93;
  double wheel_left_joint_pos  = jointstate-&#62;position&#91;1&#93;; // 左車軸の位置&#91;rad&#93;

  // 車軸の位置は積算される
  ROS_INFO("Whell Pos (r:%f, l:%f)", wheel_right_joint_pos,wheel_left_joint_pos);
}




int main(int argc, char **argv)
{
  ros::init(argc, argv, "my_odom3");
  ros::NodeHandle nh;

  //subscriberの作成。トピック/cmd_velを購読する。
  ros::Subscriber sub  = nh.subscribe("/cmd_vel", 10, cbVel);
  ros::Subscriber sub2 = nh.subscribe("/odom", 100, cbOdom);
  ros::Subscriber sub3 = nh.subscribe("/gazebo/model_states", 100, cbModelStates);
  ros::Subscriber sub4 = nh.subscribe("/joint_states", 100, cbMyOdom);
  
  
  // コールバック関数を繰り返し呼び出す。
  ros::Rate rate(100);

  while (ros::ok()) {

    
    ros::spinOnce();
    rate.sleep();
  }
  return 0;
}
</pre>
<ul>
<li>以下ファイルをダウンロードして~/catkin_ws/srcの下にコピーする。
<ul>
<li><a href="http://demura.net/wordpress/wp-content/uploads/2018/11/my_odom3.tar">my_odom3.tar</a></li>
</ul>
</li>
<li>ビルドする
<ul>
<li><code>$ cd ~/catkin_ws/src</code></li>
<li><code>$ tar xvf my_odom3.tar</code></li>
<li><code>$ cd ~/catkin_ws</code></li>
<li><code>$ catkin_make</code></li>
</ul>
</li>
<li>rvizでの実行
<ul>
<li>端末を３つ開き、各端末で以下のコマンドを実行する。</li>
<li><code>$ roslaunch turtlebot3_fake turtlebot3_fake.launch</code></li>
<li><code>$ roslaunch turtlebot3_teleop turtlebot3_teleop_key.launch</code></li>
<li><code>$ rosrun my_odom3  my_odom3</code></li>
</ul>
</li>
<li>gazeboでの実行
<ul>
<li>端末を３つ開き、各端末で以下のコマンドを実行する。</li>
<li><code>$ roslaunch turtlebot3_gazebo turtlebot3_empty_world.launch</code></li>
<li><code>$ roslaunch turtlebot3_teleop turtlebot3_teleop_key.launch</code></li>
<li><code>$ rosrun my_odom3  my_odom3</code></li>
<li>以下のコマンドでノードとトピックの関係を見てみましょう。
<ul>
<li><code>$ rqt_graph</code></li>
</ul>
</li>
<li>以下のように表示されれば成功です。<br />
<a href="http://demura.net/wordpress/wp-content/uploads/2018/11/7612aedddbd4d95d3608f16b509aba98.png"><img src="{{ site.baseurl }}/assets/images/2018/11/7612aedddbd4d95d3608f16b509aba98.png" alt="" width="1385" height="712" class="aligncenter size-full wp-image-15376" /></a></li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p><strong>演  習</strong></p>
<ul>
<li>準　備
<ul>
<li>ホームディレクトリの名前が日本語の場合はコマンド操作がやりづらいので以下のコマンドで英語に変更する。
<ul>
<li><code>$ LANG=C xdg-user-dirs-gtk-update</code></li>
</ul>
</li>
<li><code>$ cd</code></li>
<li><code></code><a href="http://demura.net/wordpress/wp-content/uploads/2018/11/fmt_world-2.tar">fmt_world-2.tar</a>をクリックしてダウンロードし~/Downloadsの中に保存。</li>
<li><code>$ cd Downloads</code></li>
<li><code>$ tar xvf  fmt_world-2.tar</code></li>
<li><code>$ cd fmt_world</code></li>
<li><code>$ cp turtlebot3_fmt_world.launch  ~/catkin_ws/src/turtlebot3_simulations/turtlebot3_gazebo/launch</code></li>
<li><code>$ cp  fmt.world  ~/catkin_ws/src/turtlebot3_simulations/turtlebot3_gazebo/worlds</code></li>
<li><code>$ cp -r fmt ~/.gazebo/models</code></li>
<li><code>$ roslaunch turtlebot3_gazebo turtlebot3_fmt_world.launch</code></li>
<li>下のような建物とロボットが表示されたら終わり。右奥のボールがゴール。<a href="http://demura.net/wordpress/wp-content/uploads/2018/06/building.jpg"><img src="{{ site.baseurl }}/assets/images/2018/11/building-1024x617.jpg" alt="" width="800" height="482" class="aligncenter size-large wp-image-14644" /></a></li>
</ul>
</li>
<li><strong>演　習（レポート２）</strong>
<ul>
<li>基本動作
<ul>
<li>Turtlebot3を指定の距離[m]だけ直進して停止するプログラムを作ろう</li>
<li>Turtlebot3を指定の角度[°]だけ回転して停止するプログラムを作ろう</li>
<li>Turtllebot3を矩形軌道を移動するプログラムを作ろう</li>
</ul>
</li>
<li>ウェイポイントナビゲーション
<ul>
<li>スタート地点からゴールまで進むプログラムを作ろう。</li>
</ul>
</li>
<li>デッドレコニング
<ul>
<li>デッドレコニングをcbMyOdom関数に実装しよう。rvizの場合は/odomトピックと値を比較し、gazeboが動く場合はシミュレータ上の真の位置Real Posと比較しよう。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>終わり</p>
