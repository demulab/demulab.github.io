---
layout: post
title: ROS演習6：デッドレコニングを実装しよう！
date: 2019-05-28 12:53:37.000000000 +09:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- lecture
tags: []
meta:
  _edit_last: '2'
  _thumbnail_id: '15376'
  views: '972'
  _quads_config_visibility: a:0:{}
  the_page_seo_title: ''
  the_page_meta_description: ''
  the_page_meta_keywords: ''
  the_page_noindex: '0'
  the_page_nofollow: '0'
  the_page_ads_novisible: '0'
  page_type: default
  the_page_toc_novisible: '0'
  update_level: high
  redirect_url: ''
  the_page_no_amp: '0'
  _custom_css: ''
  _custom_js: ''
  the_page_memo: ''
  sns_image_url: ''
author:
  login: demu
  email: info@demura.net
  display_name: demu
  first_name: ''
  last_name: ''
permalink: "/education/lecture/15829.html"
---
<p>今回はTurtlebot3にデッドレコニングを実装します。</p>
<ul>
<li>デッドレコニング説明資料
<ul>
<li>以下の説明資料をダウンロードして読んでください。これをGazebo上のTurtlebot3に実装していきましょう。
<ul>
<li><a href="http://demura.net/wordpress/wp-content/uploads/2018/11/deadReckoning.pdf">deadReckoning.pdf</a></li>
</ul>
</li>
</ul>
</li>
<li>テンプレートファイル</li>
</ul>
<pre class="brush:cpp;">// ファイル名　my_odom3.cpp
#include &#60;ros/ros.h&#62;  // rosで必要はヘッダーファイル
#include &#60;geometry_msgs/Twist.h&#62; // ロボットを動かすために必要
#include &#60;nav_msgs/Odometry.h&#62;
#include &#60;tf/transform_broadcaster.h&#62;
#include &#60;tf/transform_datatypes.h&#62;
#include &#60;gazebo_msgs/ModelStates.h&#62; 
#include &#60;sensor_msgs/JointState.h&#62;
#include 

using namespace std;

// コールバック関数。並進、回転速度の表示。
void cbVel(const geometry_msgs::Twist::ConstPtr&amp; vel) {
  cout &#60;&#60; "Linear :" &#60;&#60; vel-&#62;linear.x &#60;&#60; endl;
  cout &#60;&#60; "Angular:" &#60;&#60; vel-&#62;angular.z &#60;&#60; endl; } // /odomトピックから位置posと姿勢poseを表示 void cbOdom(const nav_msgs::Odometry::ConstPtr&amp; msg) { ROS_INFO("Seq: %d", msg-&#62;header.seq);
  ROS_INFO("/odom Pos (x:%f, y:%f, z:%f)", msg-&#62;pose.pose.position.x,msg-&#62;pose.pose.position.y, msg-&#62;pose.pose.position.z);

  tf::Quaternion q(msg-&#62;pose.pose.orientation.x, msg-&#62;pose.pose.orientation.y, msg-&#62;pose.pose.orientation.z, msg-&#62;pose.pose.orientation.w);  
  // tf::Quaternion q(quat.x, quat.y, quat.z, quat.w);
  tf::Matrix3x3 m(q);
  double roll, pitch, yaw;
  m.getRPY(roll, pitch, yaw);

  ROS_INFO("/odom Pose (roll:%f, pitch:%f, yaw:%f) ", roll, pitch, yaw);
  ROS_INFO("Vel (Linear:%f, Angular:%f)", msg-&#62;twist.twist.linear.x,msg-&#62;twist.twist.angular.z);
												  
}

// /gazebo/model_statesトピックから真の位置Pos(x,y,z)と姿勢Pose(roll, pitch ,yaw)を表示
void cbModelStates(const gazebo_msgs::ModelStates::ConstPtr&amp; msg)
{
  ROS_INFO("Real Pos (x:%f, y:%f, z:%f)", msg-&#62;pose&#91;1&#93;.position.x,msg-&#62;pose&#91;1&#93;.position.y, msg-&#62;pose&#91;1&#93;.position.z);

  tf::Quaternion q(msg-&#62;pose&#91;1&#93;.orientation.x, msg-&#62;pose&#91;1&#93;.orientation.y, msg-&#62;pose&#91;1&#93;.orientation.z, msg-&#62;pose&#91;1&#93;.orientation.w);  
  // tf::Quaternion q(quat.x, quat.y, quat.z, quat.w);
  tf::Matrix3x3 m(q);
  double roll, pitch, yaw;
  m.getRPY(roll, pitch, yaw);

  ROS_INFO("Real Pose (roll:%f, pitch:%f, yaw:%f) ", roll, pitch, yaw);
												  
}

// cbMyOdom：この関数に自分のオドメトリを実装しよう！
// /joint_statesトピックから左右のjoint(車輪回転軸)の位置（回転角度)&#91;rad&#93;を表示
// 参考：Turtlebot3の車輪直径0.066 &#91;m&#93;
void cbMyOdom(const sensor_msgs::JointState::ConstPtr&amp; jointstate)
{
  double wheel_right_joint_pos = jointstate-&#62;position&#91;0&#93;; // 右車軸の位置&#91;rad&#93;
  double wheel_left_joint_pos  = jointstate-&#62;position&#91;1&#93;; // 左車軸の位置&#91;rad&#93;

  // 車軸の位置は積算される
  ROS_INFO("Whell Pos (r:%f, l:%f)", wheel_right_joint_pos,wheel_left_joint_pos);
}




int main(int argc, char **argv)
{
  ros::init(argc, argv, "my_odom3");
  ros::NodeHandle nh;

  //subscriberの作成。トピック/cmd_velを購読する。
  ros::Subscriber sub  = nh.subscribe("/cmd_vel", 10, cbVel);
  ros::Subscriber sub2 = nh.subscribe("/odom", 100, cbOdom);
  ros::Subscriber sub3 = nh.subscribe("/gazebo/model_states", 100, cbModelStates);
  ros::Subscriber sub4 = nh.subscribe("/joint_states", 100, cbMyOdom);
  
  
  // コールバック関数を繰り返し呼び出す。
  ros::Rate rate(100);

  while (ros::ok()) {

    
    ros::spinOnce();
    rate.sleep();
  }
  return 0;
}
</pre>
<ul>
<li>以下ファイルをダウンロードして~/catkin_ws/srcの下にコピーする。
<ul>
<li><a href="http://demura.net/wordpress/wp-content/uploads/2018/11/my_odom3.tar">my_odom3.tar</a></li>
</ul>
</li>
<li>ビルドする
<ul>
<li><code>$ cd ~/catkin_ws/src</code></li>
<li><code>$ tar xvf my_odom3.tar</code></li>
<li><code>$ cd ~/catkin_ws</code></li>
<li><code>$ catkin_make</code></li>
</ul>
</li>
<li>rvizでの実行
<ul>
<li>端末を３つ開き、各端末で以下のコマンドを実行する。</li>
<li><code>$ roslaunch turtlebot3_fake turtlebot3_fake.launch</code></li>
<li><code>$ roslaunch turtlebot3_teleop turtlebot3_teleop_key.launch</code></li>
<li><code>$ rosrun my_odom3  my_odom3</code></li>
</ul>
</li>
<li>gazeboでの実行
<ul>
<li>端末を３つ開き、各端末で以下のコマンドを実行する。</li>
<li><code>$ roslaunch turtlebot3_gazebo turtlebot3_empty_world.launch</code></li>
<li><code>$ roslaunch turtlebot3_teleop turtlebot3_teleop_key.launch</code></li>
<li><code>$ rosrun my_odom3  my_odom3</code></li>
<li>以下のコマンドでノードとトピックの関係を見てみましょう。
<ul>
<li><code>$ rqt_graph</code></li>
</ul>
</li>
<li>以下のように表示されれば成功です。<br />
<a href="http://demura.net/wordpress/wp-content/uploads/2018/11/7612aedddbd4d95d3608f16b509aba98.png"><img class="aligncenter size-full wp-image-15376" src="{{ site.baseurl }}/assets/images/2019/05/7612aedddbd4d95d3608f16b509aba98.png" alt="" width="1385" height="712" /></a></li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p><strong>演  習</strong></p>
<ul>
<li>準　備
<ul>
<li>ホームディレクトリの名前が日本語の場合はコマンド操作がやりづらいので以下のコマンドで英語に変更する。
<ul>
<li><code>$ LANG=C xdg-user-dirs-gtk-update</code></li>
</ul>
</li>
<li><code>$ cd</code></li>
<li><code></code><a href="http://demura.net/wordpress/wp-content/uploads/2018/11/fmt_world-2.tar">fmt_world-2.tar</a>をクリックしてダウンロードし~/Downloadsの中に保存。</li>
<li><code>$ cd Downloads</code></li>
<li><code>$ tar xvf  fmt_world-2.tar</code></li>
<li><code>$ cd fmt_world</code></li>
<li><code>$ cp turtlebot3_fmt_world.launch  ~/catkin_ws/src/turtlebot3_simulations/turtlebot3_gazebo/launch</code></li>
<li><code>$ cp  fmt.world  ~/catkin_ws/src/turtlebot3_simulations/turtlebot3_gazebo/worlds</code></li>
<li><code>$ cp -r fmt ~/.gazebo/models</code></li>
<li><code>$ roslaunch turtlebot3_gazebo turtlebot3_fmt_world.launch</code></li>
<li>下のような建物とロボットが表示されたら終わり。右奥のボールがゴール。<a href="http://demura.net/wordpress/wp-content/uploads/2018/06/building.jpg"><img class="aligncenter size-large wp-image-14644" src="{{ site.baseurl }}/assets/images/2019/05/building-1024x617.jpg" alt="" width="800" height="482" /></a></li>
</ul>
</li>
<li><strong>演　習（レポート２）</strong>
<ul>
<li>基本動作
<ul>
<li>Turtlebot3を指定の距離[m]だけ直進して停止するプログラムを作ろう</li>
<li>Turtlebot3を指定の角度[°]だけ回転して停止するプログラムを作ろう</li>
<li>Turtllebot3を矩形軌道を移動するプログラムを作ろう</li>
</ul>
</li>
<li>ウェイポイントナビゲーション
<ul>
<li>スタート地点からゴールまで進むプログラムを作ろう。</li>
</ul>
</li>
<li>デッドレコニング
<ul>
<li>デッドレコニングをcbMyOdom関数に実装しよう。rvizの場合は/odomトピックと値を比較し、gazeboが動く場合はシミュレータ上の真の位置Real Posと比較しよう。</li>
</ul>
</li>
</ul>
</li>
<li>ヒント
<ul>
<li>Gazeboを起動するとTurtlebot3に速度指令を送らなくても滑って動く場合があります。その場合は次のパラメータを変更してみてください。
<ul>
<li>turtlebot3/turtlebot3_description/urdf/turtlebot3_burger.gazebo.xacro
<ul>
<li>11,12, 21,22行目パラメータ摩擦係数mu1,mu2を0.1から1以下の大きな値。
<ul>
<li>&lt;mu1&gt;1.0&lt;/mu1&gt;<br />
&lt;mu2&gt;1.0&lt;/mu2&gt;</li>
</ul>
</li>
<li>mu1, mu2を変化させてもスリップする場合はkp, kdのパラメータを変えましょう。gazeboは動力学計算にODEを使っており、ODEのdt(時間ステップ）、erp、cfmとは次の関係があります。
<ul>
<li>kp = erp/ (dt* cfm)</li>
<li>kd = (1.0- erp)/cfm</li>
</ul>
</li>
<li>kp, kd, dtからerp, cfmを求める式
<ul>
<li>erp = dt * kp / (dt * kp + kd)</li>
<li>cfm = 1.0 / (dt * kp + kd)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>終わり</p>
