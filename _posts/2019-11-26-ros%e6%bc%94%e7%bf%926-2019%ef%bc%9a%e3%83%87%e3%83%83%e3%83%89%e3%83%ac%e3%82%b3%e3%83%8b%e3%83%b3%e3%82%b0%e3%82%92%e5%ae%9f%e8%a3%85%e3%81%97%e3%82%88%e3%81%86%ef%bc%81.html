---
layout: post
title: ROS演習7-2019：デッドレコニングを実装しよう！
date: 2019-11-26 18:13:08.000000000 +09:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- education
tags: []
meta:
  _edit_last: '2'
  views: '1923'
  _thumbnail_id: '15454'
  _quads_config_visibility: a:0:{}
  the_page_seo_title: ''
  the_page_meta_description: ''
  the_page_meta_keywords: ''
  the_page_noindex: '0'
  the_page_nofollow: '0'
  the_page_canonical_url: ''
  the_page_ads_novisible: '0'
  page_type: default
  the_page_read_time_novisible: '0'
  the_page_toc_novisible: '0'
  update_level: high
  the_review_enable: '0'
  the_review_type: Product
  the_review_name: ''
  the_review_rate: '5'
  redirect_url: ''
  the_page_no_amp: '0'
  _custom_css: ''
  _custom_js: ''
  the_page_memo: ''
  sns_image_url: ''
  _wp_old_date: '2019-10-15'
author:
  login: demu
  email: info@demura.net
  display_name: demu
  first_name: ''
  last_name: ''
permalink: "/education/16291.html"
---
<p>今回はTurtlebot3にデッドレコニングを実装します。</p>
<ul>
<li>デッドレコニング説明資料
<ul>
<li>以下の説明資料をダウンロードして読んでください。これをGazebo上のTurtlebot3に実装していきましょう。
<ul>
<li><a href="http://demura.net/wordpress/wp-content/uploads/2018/11/deadReckoning.pdf">deadReckoning.pdf</a></li>
<li><a href="http://edu1.kanazawa-it.ac.jp/~demura/education/robotProg2/robotProg2-week7-191114.pdf">講義７週PPT（学内のみダウンロード可能）</a></li>
</ul>
</li>
</ul>
</li>
<li>ROSの座標系
<ul>
<li>ROSではロボットの進行方向がx軸、左方向がy軸、上方向がz軸の正方向です。回転方向は反時計周りが正(0~π[rad])、時計回りが負(0~-π[rad])となります。</li>
</ul>
</li>
<li>テンプレートファイル</li>
</ul>
<pre class="brush:cpp;">// ファイル名　my_odom3.cpp
#include &#60;ros/ros.h&#62;  // rosで必要はヘッダーファイル
#include &#60;geometry_msgs/Twist.h&#62; // ロボットを動かすために必要
#include &#60;nav_msgs/Odometry.h&#62;
#include &#60;tf/transform_broadcaster.h&#62;
#include &#60;tf/transform_datatypes.h&#62;
#include &#60;gazebo_msgs/ModelStates.h&#62; 
#include &#60;sensor_msgs/JointState.h&#62;
#include 

using namespace std;

// コールバック関数。並進、回転速度の表示。
void cbVel(const geometry_msgs::Twist::ConstPtr&amp; vel) {
  cout &#60;&#60; "Linear :" &#60;&#60; vel-&#62;linear.x &#60;&#60; endl;
  cout &#60;&#60; "Angular:" &#60;&#60; vel-&#62;angular.z &#60;&#60; endl; } 

// /odomトピックから位置posと姿勢poseを表示 
void cbOdom(const nav_msgs::Odometry::ConstPtr&amp; msg) { 
  ROS_INFO("Seq: %d", msg-&#62;header.seq);
  ROS_INFO("/odom Pos (x:%f, y:%f, z:%f)", msg-&#62;pose.pose.position.x,msg-&#62;pose.pose.position.y, msg-&#62;pose.pose.position.z);

  tf::Quaternion q(msg-&#62;pose.pose.orientation.x, msg-&#62;pose.pose.orientation.y, msg-&#62;pose.pose.orientation.z, msg-&#62;pose.pose.orientation.w);  
  // tf::Quaternion q(quat.x, quat.y, quat.z, quat.w);
  tf::Matrix3x3 m(q);
  double roll, pitch, yaw;
  m.getRPY(roll, pitch, yaw);

  ROS_INFO("/odom Pose (roll:%f, pitch:%f, yaw:%f) ", roll, pitch, yaw);
  ROS_INFO("Vel (Linear:%f, Angular:%f)", msg-&#62;twist.twist.linear.x,msg-&#62;twist.twist.angular.z);
												  
}

// /gazebo/model_statesトピックから真の位置Pos(x,y,z)と姿勢Pose(roll, pitch ,yaw)を表示
void cbModelStates(const gazebo_msgs::ModelStates::ConstPtr&amp; msg)
{
  ROS_INFO("Real Pos (x:%f, y:%f, z:%f)", msg-&#62;pose&#91;1&#93;.position.x,msg-&#62;pose&#91;1&#93;.position.y, msg-&#62;pose&#91;1&#93;.position.z);

  tf::Quaternion q(msg-&#62;pose&#91;1&#93;.orientation.x, msg-&#62;pose&#91;1&#93;.orientation.y, msg-&#62;pose&#91;1&#93;.orientation.z, msg-&#62;pose&#91;1&#93;.orientation.w);  
  // tf::Quaternion q(quat.x, quat.y, quat.z, quat.w);
  tf::Matrix3x3 m(q);
  double roll, pitch, yaw;
  m.getRPY(roll, pitch, yaw);

  ROS_INFO("Real Pose (roll:%f, pitch:%f, yaw:%f) ", roll, pitch, yaw);
												  
}

// cbMyOdom：この関数に自分のオドメトリを実装しよう！
// /joint_statesトピックから左右のjoint(車輪回転軸)の位置（回転角度)&#91;rad&#93;を表示
// 参考：Turtlebot3の車輪直径0.066 &#91;m&#93;
void cbMyOdom(const sensor_msgs::JointState::ConstPtr&amp; jointstate)
{
  double wheel_right_joint_pos = jointstate-&#62;position&#91;0&#93;; // 右車軸の位置&#91;rad&#93;
  double wheel_left_joint_pos  = jointstate-&#62;position&#91;1&#93;; // 左車軸の位置&#91;rad&#93;

  // 車軸の位置は積算される
  ROS_INFO("Whell Pos (r:%f, l:%f)", wheel_right_joint_pos,wheel_left_joint_pos);
}




int main(int argc, char **argv)
{
  ros::init(argc, argv, "my_odom3");
  ros::NodeHandle nh;

  //subscriberの作成。トピック/cmd_velを購読する。
  ros::Subscriber sub  = nh.subscribe("/cmd_vel", 10, cbVel);
  ros::Subscriber sub2 = nh.subscribe("/odom", 100, cbOdom);
  ros::Subscriber sub3 = nh.subscribe("/gazebo/model_states", 100, cbModelStates);
  ros::Subscriber sub4 = nh.subscribe("/joint_states", 100, cbMyOdom);
  
  
  // コールバック関数を繰り返し呼び出す。
  ros::Rate rate(100);

  while (ros::ok()) {

    
    ros::spinOnce();
    rate.sleep();
  }
  return 0;
}
</pre>
<ul>
<li>以下ファイルをダウンロードして~/catkin_ws/srcの下にコピーする。
<ul>
<li><a href="http://demura.net/wordpress/wp-content/uploads/2018/11/my_odom3.tar">my_odom3.tar</a></li>
</ul>
</li>
<li>ビルドする
<ul>
<li><code>$ cd ~/catkin_ws/src</code></li>
<li><code>$ tar xvf my_odom3.tar</code></li>
<li><code>$ cd ~/catkin_ws</code></li>
<li><code>$ catkin build</code></li>
</ul>
</li>
<li>rvizでの実行
<ul>
<li>端末を３つ開き、各端末で以下のコマンドを実行する。</li>
<li><code>$ roslaunch turtlebot3_fake turtlebot3_fake.launch</code></li>
<li><code>$ roslaunch turtlebot3_teleop turtlebot3_teleop_key.launch</code></li>
<li><code>$ rosrun my_odom3  my_odom3</code></li>
</ul>
</li>
<li>gazeboでの実行
<ul>
<li>端末を３つ開き、各端末で以下のコマンドを実行する。</li>
<li><code>$ roslaunch turtlebot3_gazebo turtlebot3_empty_world.launch</code></li>
<li><code>$ roslaunch turtlebot3_teleop turtlebot3_teleop_key.launch</code></li>
<li><code>$ rosrun my_odom3  my_odom3</code></li>
<li>以下のコマンドでノードとトピックの関係を見てみましょう。
<ul>
<li><code>$ rqt_graph</code></li>
</ul>
</li>
<li>以下のように表示されれば成功です。<br />
<a href="http://demura.net/wordpress/wp-content/uploads/2018/11/7612aedddbd4d95d3608f16b509aba98.png"><img class="aligncenter size-full wp-image-15376" src="{{ site.baseurl }}/assets/images/2019/11/7612aedddbd4d95d3608f16b509aba98.png" alt="" width="1385" height="712" /></a></li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p><strong>演  習</strong></p>
<ul>
<li>準　備
<ul>
<li>ホームディレクトリの名前が日本語の場合はコマンド操作がやりづらいので以下のコマンドで英語に変更する。以下のウインドウが開くので[UpdateNames]をクリックすると英語名に変わる。
<ul>
<li><code>$ LANG=C xdg-user-dirs-gtk-update<br />
</code><br />
<a href="https://demura.net/wordpress/wp-content/uploads/2019/10/SnapCrab_NoName_2019-11-19_14-26-6_No-00.png"><img class="aligncenter size-full wp-image-16384" src="{{ site.baseurl }}/assets/images/2019/11/SnapCrab_NoName_2019-11-19_14-26-6_No-00.png" alt="" width="648" height="517" /></a></li>
</ul>
</li>
<li><code>$ cd</code></li>
<li><code></code><a href="http://demura.net/wordpress/wp-content/uploads/2018/11/fmt_world-2.tar">fmt_world-2.tar</a>をクリックしてダウンロードし~/Downloadsの中に保存。</li>
<li><code>$ cd Downloads</code></li>
<li><code>$ tar xvf  fmt_world-2.tar</code></li>
<li><code>$ cd fmt_world</code></li>
<li><code>$ cp turtlebot3_fmt_world.launch  ~/catkin_ws/src/turtlebot3_simulations/turtlebot3_gazebo/launch</code></li>
<li><code>$ cp  fmt.world  ~/catkin_ws/src/turtlebot3_simulations/turtlebot3_gazebo/worlds</code></li>
<li><code>$ cp -r fmt ~/.gazebo/models</code></li>
<li><code>$ roslaunch turtlebot3_gazebo turtlebot3_fmt_world.launch</code></li>
<li>下のような建物とロボットが表示されたら終わり。右奥のボールがゴール。<a href="http://demura.net/wordpress/wp-content/uploads/2018/06/building.jpg"><img class="aligncenter size-large wp-image-14644" src="{{ site.baseurl }}/assets/images/2019/11/building-1024x617.jpg" alt="" width="800" height="482" /></a></li>
</ul>
</li>
<li><strong>演　習（レポート２）</strong>
<ul>
<li>準備
<ul>
<li>以下のROS C++スタイルガイドを参考にRobotクラスを作ろう。
<ul>
<li><a href="http://wiki.ros.org/ja/CppStyleGuide">ROS C++ スタイルガイド - ROS Wiki - ROS.org</a></li>
</ul>
</li>
</ul>
</li>
<li> 基本動作
<ol>
<li>Turtlebot3を指定速度[m/s]で直進する以下のメンバ関数を作ろう。
<ul>
<li>void Robot::moveAtSpeed(double linear_vel)</li>
</ul>
</li>
<li>Turtlebot3を指定角速度[rad/s]で回転する以下のメンバ関数を作ろう。
<ul>
<li>void Robot::turnAtSpeed(double ang_vel)</li>
</ul>
</li>
<li>Turtlebot3を指定速度[m/s]で指定の距離[m]だけ直進して停止する以下のメンバ関数を作ろう。
<ul>
<li>void Robot::moveToDistance(double linear_vel, double dist)</li>
</ul>
</li>
<li>Turtlebot3を指定角速度[°/s]で指定の角度[°]だけ回転して停止する以下のメンバ関数を作ろう。
<ul>
<li>void Robot::turnToAngle(double ang_vel, double angle)</li>
</ul>
</li>
<li>Turtlebot3を指定位置（ロボット座標系）へ移動する以下のメンバ関数を作ろう。なお、ROSの座標系なのでロボットの進行方向がx、左方向がy軸の正方向です。
<ul>
<li>void Robot::moveToPoint(double x, double y)</li>
</ul>
</li>
</ol>
</li>
<li>ウェイポイントナビゲーション
<ul>
<li>スタート地点からゴールまで進むプログラムを作ろう。ロボットが通過するウェイポイントとその地点での姿勢を配列として実装しなさい。ロボットはウェイポイントで停止してもしなくても良いが、指定された姿勢を取ること。</li>
</ul>
</li>
<li>デッドレコニング
<ul>
<li>デッドレコニングをcbMyOdom関数に実装しよう。rvizの場合は/odomトピックと値を比較し、gazeboが動く場合はシミュレータ上の真の位置Real Posと比較しよう。</li>
</ul>
</li>
</ul>
</li>
<li>ヒント
<ul>
<li>Gazeboを起動するとTurtlebot3に速度指令を送らなくても滑って動く場合があります。その場合は次のパラメータを変更してみてください。
<ul>
<li>turtlebot3/turtlebot3_description/urdf/turtlebot3_burger.gazebo.xacro
<ul>
<li>11,12, 21,22行目パラメータ摩擦係数mu1,mu2を0.1から1以下の大きな値。
<ul>
<li>&lt;mu1&gt;1.0&lt;/mu1&gt;<br />
&lt;mu2&gt;1.0&lt;/mu2&gt;</li>
</ul>
</li>
<li>mu1, mu2を変化させてもスリップする場合はkp, kdのパラメータを変えましょう。gazeboは動力学計算にODEを使っており、ODEのdt(時間ステップ）、erp、cfmとは次の関係があります。
<ul>
<li>kp = erp/ (dt* cfm)</li>
<li>kd = (1.0- erp)/cfm</li>
</ul>
</li>
<li>kp, kd, dtからerp, cfmを求める式
<ul>
<li>erp = dt * kp / (dt * kp + kd)</li>
<li>cfm = 1.0 / (dt * kp + kd)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>終わり</p>
